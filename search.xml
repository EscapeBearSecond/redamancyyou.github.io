<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>设计模式-观察者模式</title>
      <link href="/2022/11/17/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/11/17/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h2><p>观察者模式定义对象之间一对多或多对多的依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并自动更新。</p><p>观察者模式又叫做发布-订阅模式，有点像微信的公众号订阅，或者是B站、微博等关注用户。以微信公众号为例，在用户（观察者）关注一个公众号之后（订阅），如果该公众号有文章发布或有最新的消息（状态改变），就会通知所有关注该公众号的用户（通知），此时用户就会收到对应的消息（接收消息）。</p><h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p>观察者模式主要角色就是观察者和被观察者，被观察者官方一点说法叫做主题。观察者中有订阅主题、接收消息、取消订阅等方法，主题中有添加观察者、移除观察者、通知所有观察者，以及应包含一个观察者列表。</p><p><img src="https://gitee.com/redamancyher/blogpic/raw/master/img/202211171746372.png" alt="观察者模式"></p><p>这里Observer和Subject可以是抽象类型，具体的观察着或主题去继承并实现具体方法，这样的好处就是可以进行功能拓展。观察者模式也有很多种实现方式，具体的要根据业务进行改变，不能够死记硬背，关键是理解其中原理。</p><h2 id="举个小栗子"><a href="#举个小栗子" class="headerlink" title="举个小栗子"></a>举个小栗子</h2><p>以微信公众号作为例子，其中观察者是普通的用户（只给一个name属性进行区分不同用户），主题就是公众号。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>()&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] arges)</span>&#123;</span><br><span class="line">    <span class="type">OfficialAccount</span> <span class="variable">camellia</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OfficialAccount</span>(<span class="string">&quot;山茶花话Java&quot;</span>);</span><br><span class="line">    <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">    <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;王五&quot;</span>);</span><br><span class="line">    <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;赵六&quot;</span>);</span><br><span class="line">    user1.subscribe(camellia);</span><br><span class="line">    camellia.notifyObserver(camellia.getName(),<span class="string">&quot;我发布了一篇新闻章-数据结构之B树&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Observer</span>&#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">subscribe</span><span class="params">(Subject subject)</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">unsubscribe</span><span class="params">(Subject subject)</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">acceptMessage</span><span class="params">(String name, String message)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Observer</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> String name;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Observer</span><span class="params">(String name)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">subscribe</span><span class="params">(Subject subjecgt)</span>&#123;</span><br><span class="line">    subject.addObserver(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unsubscribe</span><span class="params">(Subject subject)</span>&#123;</span><br><span class="line">    subject.removeObserver(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">acceptMessage</span><span class="params">(String name,String message)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;这里是订阅者&quot;</span> + <span class="built_in">this</span>.getName()  + <span class="string">&quot;，收到来自&quot;</span> + name +<span class="string">&quot;的消息：&quot;</span> + message);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Subject</span>&#123;</span><br><span class="line">    List&lt;Observer&gt; observers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 观察者列表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">addObserver</span><span class="params">(Observer observer)</span>; <span class="comment">// 添加观察者</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">removeObserver</span><span class="params">(Observer observer)</span>; <span class="comment">// 移除观察者</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">notifyObserver</span><span class="params">(String name, String message)</span>; <span class="comment">// 通知观察者</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OfficalAccount</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> String name;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">OfficialAccount</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addObserver</span><span class="params">(Observer observer)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.observers.add(observer);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeObserver</span><span class="params">(Observer observer)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.observers.remove(observer);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyObserver</span><span class="params">(String name,String message)</span> &#123;</span><br><span class="line">    observers.forEach(observer -&gt; &#123;</span><br><span class="line">      observer.acceptMessage(name,message);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://gitee.com/redamancyher/blogpic/raw/master/img/202211171805964.png" alt="image-20221117180512899"></p><p>观察者模式的主要优点就是极大地降低了目标对象和观察者对象间的耦合，二者可以独自地改变和复用，让对系统增加功能或删除功能都很方便。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-B+树</title>
      <link href="/2022/11/15/B+%E6%A0%91/"/>
      <url>/2022/11/15/B+%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="B-树介绍"><a href="#B-树介绍" class="headerlink" title="B+树介绍"></a>B+树介绍</h2><p>B+树是B树的一种变形（了解B+树前要先了解<a href="https://redamancyyou.cn/2022/11/14/B%E6%A0%91/">B树</a>），B+树常用于数据库和操作系统的文件系统中。B+树的特点是能够保持数据的稳定有序，其插入与修改操作具有相对稳定的对数时间复杂度。</p><h2 id="B-树的特性"><a href="#B-树的特性" class="headerlink" title="B+树的特性"></a>B+树的特性</h2><p>B+树的特性与B树的特定基本一致，这里主要介绍一下B+树与B树的一些区别</p><ol><li>m阶B+树每个节点可以有m个关键字（其实也有介绍说是和B树一样m-1个关键字，但是MySQL中的B+树索引可以有m个）</li><li>B+树的非叶子节点不存储数据，只存储索引（主要区别）</li><li>B+树的每一层都是用双向链表进行链接，在叶子节点中，每个节点中的数据通过单向链表进行链接。（其实B树中相同层的节点也可以通过双向链表进行链接，所以这不是主要区别）</li></ol><h2 id="B-树的优点"><a href="#B-树的优点" class="headerlink" title="B+树的优点"></a>B+树的优点</h2><ol><li>B+树是一种常作为索引的数据结构，在mysql数据库中，InnoDB存储引擎的每一页的大小默认是16KB，如果非叶子节点不存储数据只存储索引值，那么就可以存储更多的键值，相应的树的阶数会变大，树会变得矮胖，如此，在进行查找数据时进行的IO次数又会减少，查询效率也会提升。</li></ol><p>举个小栗子：如果我们有10亿数据，如果B+树的每个节点键值对个数为1000，那么1000×1000×1000&#x3D;10亿，mysql中的根节点又是常驻内存的，索引我们只需要进行两次IO操作就可以查找到数据。</p><ol start="2"><li>因为B+树只有叶子节点，而且数据是按照顺序排序的，这使得B+树进行范围查找、排序查找、分组查找、去重查找变得异常简单，而B树因为数据分散在各个节点，要实现这些非常不容易。</li></ol><h2 id="B-树的插入操作"><a href="#B-树的插入操作" class="headerlink" title="B+树的插入操作"></a>B+树的插入操作</h2><ol><li>若为空树，创建一个叶子结点，然后将记录插入其中，此时这个叶子结点也是根结点，插入操作结束。</li><li>针对叶子类型结点：根据key值找到叶子结点，向这个叶子结点插入记录。插入后，若当前结点key的个数小于等于m，则插入结束。否则将这个叶子结点分裂成左右两个叶子结点，左叶子结点包含前m&#x2F;2个记录，右结点包含剩下的记录，将第m&#x2F;2+1个记录的key进位到父结点中（父结点一定是索引类型结点），进位到父结点的key左孩子指针向左结点,右孩子指针向右结点。将当前结点的指针指向父结点，然后执行第3步。</li><li>针对索引类型结点：若插入后当前结点key的个数小于等于m，则插入结束。否则，将这个索引类型结点分裂成两个索引结点，左索引结点包含前(m-1)&#x2F;2个key，右结点包含m-(m-1)&#x2F;2个key，将第m&#x2F;2个key进位到父结点中，进位到父结点的key左孩子指向左结点, 进位到父结点的key右孩子指向右结点。将当前结点的指针指向父结点，然后重复第3步。</li></ol><p>注意：叶子节点和索引节点的分裂方式不太一样，索引节点分裂后关键字不会在子节点中出现，而叶子节点会出现</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-B树</title>
      <link href="/2022/11/14/B%E6%A0%91/"/>
      <url>/2022/11/14/B%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="B树出现的原因"><a href="#B树出现的原因" class="headerlink" title="B树出现的原因"></a>B树出现的原因</h2><p>为了解决树做索引结构时，数据库频繁进行IO操作降低查询性能的问题。</p><h2 id="B树特性"><a href="#B树特性" class="headerlink" title="B树特性"></a>B树特性</h2><ol><li>一颗m阶B树，树种每个节点最多含有m棵子树</li><li>若根节点不是叶子节点，则至少有两棵子树</li><li>除根节点外的所有非终端节点至少有⌈m&#x2F;2⌉（向上取整）棵子树</li><li>如果一个节点有n-1个关键字，则该节点有n棵子树，且n-1个关键字按照递增顺序排序</li><li>每个非终端节点包含的信息：(N, A0, K1, A1, K2, …, KN…)<ul><li>Ki(1≤i≤n)为关键字</li><li>指针Ai指向该节点子树的根节点，Ai-1指向子树种所有节点的关键字均小于Ki，且大于Ki-1</li><li>关键字个数n必须满足⌈m&#x2F;2⌉-1≤n≤m-1</li></ul></li><li>所有叶子节点都在同一层，可以为空，表示查找失败</li></ol><p><img src="https://raw.githubusercontent.com/RedamancyYou/BlogPic/main/B%E6%A0%91%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="5阶B树示意图"></p><h2 id="B树的查找操作"><a href="#B树的查找操作" class="headerlink" title="B树的查找操作"></a>B树的查找操作</h2><p>B-树的查找很简单，是二叉排序树的扩展，二叉排序树是二路查找，B树是多路查找，因为B树结点内的关键字是有序的，在结点内进行查找时除了顺序查找外，还可以用折半查找来提升效率。B树的具体查找步骤如下（假设查找的关键字为key）</p><ul><li>先让key与根结点中的关键字比较，如果key等于K [i]（K []为结点内的关键字数组），则查找成功。</li><li>若key&lt;K [1]，则到P [0]所指示的子树中进行继续查找（对p[]为结点内的指针数组），这里要注意B-树中每个结点的内部结构。</li><li>若key&gt; K [n]的，则到P [n]所指示的子树中继续查找。</li><li>若k [i] &lt;key &lt;k [i + 1]，则沿着指针p [i]所指示的子树继续查找。</li><li>如果最后遇到空指针，则证明查找不成功。</li></ul><h2 id="B树的插入操作"><a href="#B树的插入操作" class="headerlink" title="B树的插入操作"></a>B树的插入操作</h2><p>B树的插入依赖于查找操作，先查找到关键字key待插入的位置，插入后看是否打破了B树的某种规则（比较重要的是上述规则中第三点和第五点中的第三小点），进行分裂等操作。</p><p>演示五阶B树，插入顺序为：39 22 97 41 53 13 21 40 30 27 33 36 35 34 24 29 26 27 17 28 29 31 32</p><p>五阶B树的关键字个数2≤n≤4</p><ul><li>插入 39 22 97 41 时正常插入</li></ul><p><img src="https://raw.githubusercontent.com/RedamancyYou/BlogPic/main/image-20221114154923652.png" alt="image-20221114154923652"></p><ul><li>插入53时，当前节点的关键字个数大于4个，所以以key值为41为中心进行分裂，结果如下图所示，分裂后当前结点指针指向父结点，满足B树条件，插入操作结束。当阶数m为偶数时，需要分裂时就不存在排序恰好在中间的key，那么我们选择中间位置的前一个key或中间位置的后一个key为中心进行分裂即可。</li></ul><p><img src="https://raw.githubusercontent.com/RedamancyYou/BlogPic/main/image-20221114155344220.png" alt="image-20221114155344220"></p><p>注意：之所以要将当前节点转移到父节点，是因为怕分裂后，会造成父节点的关键字个数也超过4，所以要对父节点继续进行判断</p><p>最终结果为：</p><p><img src="https://gitee.com/redamancyher/blogpic/raw/master/img/%E7%BB%93%E6%9E%9C.png" alt="结果"></p><h2 id="B树的删除操作"><a href="#B树的删除操作" class="headerlink" title="B树的删除操作"></a>B树的删除操作</h2><p>删除操作是指，根据key（关键字）删除记录，如果B树中的记录中不存对应key的记录，则删除失败。</p><ol><li>如果当前需要删除的key位于非叶子结点上，则用后继key（这里的后继key均指后继记录的意思）覆盖要删除的key，然后在后继key所在的子支中删除该后继key。此时后继key一定位于叶子结点上，这个过程和二叉搜索树删除结点的方式类似。<strong>删除这个记录后</strong>执行第2步<ul><li>后继，该key右指针所指向的子树中第一个关键字（最小的关键字）</li><li>前驱，该key左指针所指向的子树中最后一个关键字（最大的关键字）</li></ul></li><li>如果该节点的key个数“富有”，则删除结束，否则执行第3步</li><li>如果该节点的key个数不”富有“，看兄弟节点，如果兄弟结点key个数富有，则父结点中的key下移到该结点，兄弟结点中的一个key上移，删除操作结束。如果兄弟也不富有，则执行第4步</li><li>将父结点中的key下移与当前结点及它的兄弟结点中的key合并，形成一个新的结点。原父结点中的key的两个孩子指针就变成了一个孩子指针，指向这个新结点。然后当前结点的指针指向父结点，重复上第2步。</li></ol><p>有些结点它可能即有左兄弟，又有右兄弟，那么我们任意选择一个兄弟结点进行操作即可。</p><p>下面以上面的5阶B树为例子演示删除操作</p><ul><li>删除21：21所在节点的key个数富有，所以直接删除即可</li></ul><p><img src="https://gitee.com/redamancyher/blogpic/raw/master/img/%E5%88%A0%E9%99%A421.png" alt="删除21"></p><ul><li>删除27：因为27所在节点不是叶子节点，所以要与叶子节点进行替换，找27的后继，也就是28这个关键字，将28与27交换后，删除原28位置的关键字</li></ul><p><img src="https://gitee.com/redamancyher/blogpic/raw/master/img/%E5%88%A0%E9%99%A427-1.png" alt="删除27-1"></p><p>​但是由于删除后，当前节点只有一个关键字29，不再”富有“，所以需要看其兄弟节点，这里他的左兄弟节点有3个关键字，富有，所以可以执行第3步，父节点28下移到当前节点，兄弟节点中的关键字26上移到父节点。（如果是左兄弟，则上移兄弟中的最后一个关键字，如果是右兄弟，则上移兄弟中的第一个关键字）</p><p><img src="https://gitee.com/redamancyher/blogpic/raw/master/img/%E5%88%A0%E9%99%A427-2.png" alt="删除27-2"></p><ul><li>删除32：关键字32处于叶子节点，直接删除</li></ul><p><img src="https://gitee.com/redamancyher/blogpic/raw/master/img/202211141921100.png" alt="删除32-1"></p><p>​删除后，由于当前节点的关键字个数小于2，但是其兄弟节点又不富有，所以此时要执行第4步，将关键字30，下移到当前节点，并将当前节点与其兄弟节点合并，并将当前节点指向其父节点，重复步骤2（目的是检查父节点的关键字个数下移后是否小于2）</p><p><img src="https://gitee.com/redamancyher/blogpic/raw/master/img/202211141926863.png" alt="删除32-2"></p><p>当前节点（原父节点）满足条件，所以删除结束</p><ul><li>删除40：关键字40位于叶子节点，直接删除</li></ul><p><img src="https://gitee.com/redamancyher/blogpic/raw/master/img/202211141927405.png" alt="删除40-1"></p><p>​删除后，当前节点关键字个数小于2，且其兄弟节点不富有，所以父节点关键字下移到当前节点并于兄弟节点合并（这里我选择与右兄弟合并）</p><p><img src="https://gitee.com/redamancyher/blogpic/raw/master/img/202211141931409.png" alt="删除40-2"></p><p>​当前节点指向父节点后，当前节点的关键字个数不满足要求，所以要继续调整。当前节点的兄弟节点不富有，所以讲当前节点的关键字下移到当前节点，并与兄弟节点合并</p><p><img src="https://gitee.com/redamancyher/blogpic/raw/master/img/202211141935557.png" alt="删除40-3"></p><p>​当前节点关键字个数满足要求，故删除结束，此时B树的高度降低了1</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-工厂模式</title>
      <link href="/2022/11/14/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/11/14/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="工厂模式的介绍"><a href="#工厂模式的介绍" class="headerlink" title="工厂模式的介绍"></a>工厂模式的介绍</h2><p>工厂模式属于创建型模式，它提供了一种创建对象的方式。在工厂模式中，我们创建对象时，不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。</p><h2 id="工厂模式的应用场景"><a href="#工厂模式的应用场景" class="headerlink" title="工厂模式的应用场景"></a>工厂模式的应用场景</h2><ol><li>工厂模式的目的是为了实现解耦，将对象的创建和使用进行分离，应用程序将对象的创建和初始化职责交给工厂对象。</li><li>降低代码的臃肿度，如果一个对象的创建过程需要进行大量的判断等操作，如果全部放在构造函数中，会使得构造函数变得非常臃肿。</li><li>某个类本身有很多子类，并且经常性发生变化</li></ol><h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><blockquote><p>简单介绍</p></blockquote><p>简单工厂模式，又可以称为静态工厂方法模式，在简单工厂模式中，可以通过参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。也就是说简单工厂模式一般用于创建一大类产品中的众多小类。</p><blockquote><p>类图</p></blockquote><p><img src="https://gitee.com/redamancyher/blogpic/raw/master/img/202211142133660.png" alt="简单工厂模式类图"></p><blockquote><p>代码演示</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">    <span class="comment">// 用户创建手机</span></span><br><span class="line">    <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> Factory.createPhone(<span class="number">1</span>);</span><br><span class="line">    phone.print(); <span class="comment">// 结果为：华为手机</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 抽像产品类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Phone</span>&#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 工厂类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Factory</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Phone <span class="title function_">createPhone</span><span class="params">(<span class="type">short</span> type)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(type == <span class="number">0</span>)&#123; <span class="comment">// type为0 创建苹果手机</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">iPhone</span>();</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(type == <span class="number">1</span>)&#123; <span class="comment">// type为1 创建华为手机</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HuaweiPhone</span>();</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 具体产品iPhone</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">iPhone</span> <span class="keyword">extends</span> <span class="title class_">Phone</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;苹果手机&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 具体产品HuaweiPhone</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HuaweiPhone</span> <span class="keyword">extends</span> <span class="title class_">Phone</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;华为手机&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>优缺点</p></blockquote><p>优点：实现对象的创建和使用分离，创建完全交给专门的工厂类完成，客户端成员不需要关心如何创建，只关心怎么使用</p><p>缺点：简单工厂类不够灵活，如果新增一个产品，就需要修改工厂类中创建产品的方法（判断逻辑），如果产品多的话，将会非常复杂。</p><blockquote><p>适用场景</p></blockquote><p>只有一个大类，并且这个大类下的子类较少，个人觉得三个以内可以使用。JDK中DataFormat中的get()方法使用的就是简单工厂模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> DateFormat <span class="title function_">get</span><span class="params">(LocaleProviderAdapter adapter, <span class="type">int</span> timeStyle, <span class="type">int</span> dateStyle, Locale loc)</span> &#123;</span><br><span class="line">    <span class="type">DateFormatProvider</span> <span class="variable">provider</span> <span class="operator">=</span> adapter.getDateFormatProvider();</span><br><span class="line">    DateFormat dateFormat;</span><br><span class="line">    <span class="keyword">if</span> (timeStyle == -<span class="number">1</span>) &#123;</span><br><span class="line">        dateFormat = provider.getDateInstance(dateStyle, loc);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (dateStyle == -<span class="number">1</span>) &#123;</span><br><span class="line">            dateFormat = provider.getTimeInstance(timeStyle, loc);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dateFormat = provider.getDateTimeInstance(dateStyle, timeStyle, loc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dateFormat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><p>在简单工厂模式中，如果要增加一个产品，需要修改工厂类中的创建方法，违反了开闭原则（对拓展开放，对修改关闭）。</p><blockquote><p>工厂方法模式简单介绍</p></blockquote><p>工厂方法模式定义一个创建对象的接口，让子类决定实例化哪个类。工厂方法模式将原有的工厂类，抽象成一个抽象工厂，并增加具体的工厂类来创建具体的产品。工厂方法模式使一个类的实例化延迟到其子类。</p><blockquote><p>类图</p></blockquote><p><img src="https://gitee.com/redamancyher/blogpic/raw/master/img/202211142209404.png" alt="抽象方法模式"></p><blockquote><p>代码演示</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">HuaweiFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HuaweiFactory</span>();</span><br><span class="line">    <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> factory.createPhone();</span><br><span class="line">    phone.print(); <span class="comment">// 华为手机</span></span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 抽象工厂类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Factory</span>&#123;</span><br><span class="line">Phone <span class="title function_">createPhone</span><span class="params">()</span>;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 抽象产品类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Phone</span>&#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 具体产品iPhone</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">iPhone</span> <span class="keyword">extends</span> <span class="title class_">Phone</span>&#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;苹果手机&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 具体产品HuaweiPhone</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HuaweiPhone</span> <span class="keyword">extends</span> <span class="title class_">Phone</span>&#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;华为手机&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 具体工厂</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">iPhoneFactory</span> <span class="keyword">extends</span> <span class="title class_">Factory</span>&#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">createPhone</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">iPhone</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 具体工厂</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HuaweiFactory</span> <span class="keyword">extends</span> <span class="title class_">Factory</span>&#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">createPhone</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HuaweiPhone</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>优缺点</p></blockquote><p>优点：满足程序的开闭原则，在增加一个产品时，不用修改原有的工厂类的代码</p><p>缺点：相对繁琐，增加一个产品时，不仅需要增加产品类，还要增加一个创建该产品的工厂类</p><blockquote><p>适用场景</p></blockquote><p>一个大类中有许多小类，且小类的数量可能会随着项目的进行而增加。JDK中的Collection接口中的iterator()方法</p><p><img src="https://gitee.com/redamancyher/blogpic/raw/master/img/202211150851450.png" alt="image-20221115085124191"></p><h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><blockquote><p>简单介绍</p></blockquote><p>前面的工厂方法模式和简单工厂模式都只能生产同一大类下的不同产品，抽象工厂模式不单可以生产某一大类产品，还可以生产其他大类产品，它打破了工厂与产品大类一一对应的关系</p><blockquote><p>类图</p></blockquote><p><img src="https://gitee.com/redamancyher/blogpic/raw/master/img/202211150915845.png" alt="抽象工厂模式"></p><blockquote><p>代码演示</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(Strin[] args)</span>&#123;</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 抽象工厂</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Factory</span>&#123;</span><br><span class="line">  Phone <span class="title function_">createPhone</span><span class="params">(String param)</span>;</span><br><span class="line">  Mask <span class="title function_">createMask</span><span class="params">(String param)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 具体工厂北京工厂</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BeijingFactory</span> <span class="keyword">implements</span> <span class="title class_">Factory</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> Phone <span class="title function_">createFactory</span><span class="params">(String param)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">&quot;iPhone&quot;</span>.equals(param))&#123;</span><br><span class="line">      retutrn <span class="keyword">new</span> <span class="title class_">iPhone</span>();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HuaweiPhone</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> Mask <span class="title function_">createMask</span><span class="params">(String param)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">&quot;N95&quot;</span>.equals(param))&#123;</span><br><span class="line">      retutrn <span class="keyword">new</span> <span class="title class_">N95</span>();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">N99</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 具体工厂广东工厂</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GuangdongFactory</span> <span class="keyword">implements</span> <span class="title class_">Factory</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> Phone <span class="title function_">createFactory</span><span class="params">(String param)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">&quot;iPhone&quot;</span>.equals(param))&#123;</span><br><span class="line">      retutrn <span class="keyword">new</span> <span class="title class_">iPhone</span>();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HuaweiPhone</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> Mask <span class="title function_">createMask</span><span class="params">(String param)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">&quot;N95&quot;</span>.equals(param))&#123;</span><br><span class="line">      retutrn <span class="keyword">new</span> <span class="title class_">N95</span>();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">N99</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 手机产品大类</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Phone</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">iPhone</span> <span class="keyword">implements</span> <span class="title class_">Phone</span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HuaweiPhone</span> <span class="keyword">implements</span> <span class="title class_">Phone</span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 口罩产品大类</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Mask</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">N95</span> <span class="keyword">implements</span> <span class="title class_">Mask</span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">N99</span> <span class="keyword">implements</span> <span class="title class_">Mask</span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>优缺点</p></blockquote><p>优点：可以创建多种类型的产品，可以增加大类产品</p><p>缺点：违背了开闭原则，增加一个产品后，需要在具体工厂中修改逻辑。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-红黑树</title>
      <link href="/2022/11/13/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
      <url>/2022/11/13/%E7%BA%A2%E9%BB%91%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么会出现红黑树"><a href="#为什么会出现红黑树" class="headerlink" title="为什么会出现红黑树"></a>为什么会出现红黑树</h2><ol><li><p>在红黑树出现之前，几乎所有的索引结构使用的都是二叉排序树，但是二叉排序树的缺点就是插入时可能会导致不平衡（左子树与右子树的高度不平衡），红黑树就是为了解决这一问题而出现的。</p></li><li><p>平衡二叉树不是也可以解决这个问题吗？不错，但是平衡二叉树在左右子树高度大于1时，就需要调整，在频繁插入和删除的场景下，频繁的旋转操作会使得效率大打折扣</p></li><li><p>红黑树通过牺牲严格的平衡，换入插入删除时少量的的旋转操作，整体性能优于AVL</p><ul><li>红黑树插入时的不平衡，不超过两次旋转就可以解决；删除时的不平衡，不超过三次旋转就可以解决</li></ul></li></ol><h2 id="红黑树的特性"><a href="#红黑树的特性" class="headerlink" title="红黑树的特性"></a>红黑树的特性</h2><ol><li>节点是红色或黑色（待插入节点都是红色）</li><li>根节点是黑色的</li><li>每个叶子节点都是黑色的空节点（NULL）</li><li>每个红色节点的两个子节点都是黑色</li><li>从任一节点到其每个叶子节点的所有路径都包含相同数目的黑色节点</li></ol><h2 id="红黑树的左旋与右旋"><a href="#红黑树的左旋与右旋" class="headerlink" title="红黑树的左旋与右旋"></a>红黑树的左旋与右旋</h2><p>红黑树的左旋右旋与平衡二叉树的左旋右旋一致</p><blockquote><p>左旋</p></blockquote><p>以某个节点作为支点（旋转支点），其右子节点变为旋转节点的父节点，右子节点的左子节点变为旋转节点的右子节点，旋转节点的左子节点保持不变。</p><blockquote><p>右旋</p></blockquote><p>其左子结点变为旋转节点的父节点，左子结点的右子节点变为旋转节点的左节点，旋转节点的右子节点保持不变</p><h2 id="红黑树的插入操作"><a href="#红黑树的插入操作" class="headerlink" title="红黑树的插入操作"></a>红黑树的插入操作</h2><p>红黑树的插入操作有许多种情况</p><blockquote><p>黑父</p></blockquote><p>节点插入后如果它的父节点是黑色的，不需要做任何处理</p><p><img src="https://raw.githubusercontent.com/RedamancyYou/BlogPic/main/%E9%BB%91%E7%88%B6.png" alt="黑父"></p><blockquote><p>红父</p></blockquote><p>当节点插入后它的父节点是红色时，会存在以下几种情况</p><ol><li>红叔</li></ol><p>插入节点的父亲节点的兄弟节点如果是红色的（红叔），只需要修改父、叔的颜色为黑色，祖的颜色为红色，并且回去递归检查祖节点</p><p><img src="https://raw.githubusercontent.com/RedamancyYou/BlogPic/main/%E7%BA%A2%E7%88%B6%E7%BA%A2%E5%8F%94.png" alt="红父红叔"></p><p>注意：如果祖父为红色时，破坏了某种规则，也要去解决</p><ol start="2"><li>黑叔</li></ol><p>黑叔的情况又分为许多种，且黑叔不可以通过简单的变色来完成平衡，需要通过旋转+变色来完成。</p><ul><li>Case1：父是祖的左儿子，自己是父的左儿子，父变黑，祖变红，对祖父进行右旋</li></ul><p><img src="https://raw.githubusercontent.com/RedamancyYou/BlogPic/main/%E7%BA%A2%E7%88%B6%E9%BB%91%E5%8F%94%E5%B7%A6%E5%84%BF%E5%AD%90.png" alt="红父黑叔左父左儿子"></p><ul><li>Case2：父是祖的左儿子，自己是父的右儿子，先对父进行左旋，原新节点成为父节点，让父成为新的节点，构成Case1的情况</li></ul><p><img src="https://raw.githubusercontent.com/RedamancyYou/BlogPic/main/%E7%BA%A2%E7%88%B6%E9%BB%91%E5%8F%94%E5%B7%A6%E7%88%B6%E5%8F%B3%E5%84%BF%E5%AD%90.png" alt="红父黑叔左父右儿子"></p><ul><li>Case3：父是祖的右儿子，自己是父的右儿子，父变黑，祖变红，左旋</li><li>Case4：父是祖的右儿子，自己是父的左儿子，先对父进行右旋，原新节点成为父节点，让父成为新的节点，构成Case3的情况</li></ul><p>Case3和Case4的情况与Case1和Case2情况基本一致（对称处理）</p><h2 id="删除节点后的替代节点"><a href="#删除节点后的替代节点" class="headerlink" title="删除节点后的替代节点"></a>删除节点后的替代节点</h2><p>学习红黑树的删除操作前，首先需要明白的是，删除节点前一定要找到该节点的替代节点，就是删除该节点后，哪一个节点可以出现在被删除的位置。找到替代节点后，再对整个红黑树进行调整。</p><ol><li>待删除节点有两个节点<ul><li>取后继节点或前驱节点<ul><li>后继节点：右子树中，大于待删除节点的最小值</li><li>前驱节点：左子树中，小于待删除节点的最大值</li></ul></li></ul></li><li>待删除节点只有左节点：替换节点为左子结点</li><li>待删除节点只有右节点：替换节点为右子节点</li></ol><h2 id="红黑树的删除操作"><a href="#红黑树的删除操作" class="headerlink" title="红黑树的删除操作"></a>红黑树的删除操作</h2><p>红黑树的替换比较容易，难的是替换后的修复操作。这里设X为替换后的节点</p><blockquote><p>自己是父亲的左儿子</p></blockquote><p>Case1：兄弟为红色，自己为黑色，父节点肯定是黑色（不能连续出现红色）</p><p>（1）将兄弟变为黑色，父节点变为红色；此时，以父节点为起点的左子树黑色高度降低</p><p>（2）对父节点进行左旋，以恢复左子树黑色高度；同时兄弟的左孩子成为新的兄弟</p><p><img src="https://raw.githubusercontent.com/RedamancyYou/BlogPic/main/%E5%88%A0%E9%99%A4%E9%BB%91-%E5%85%84%E7%BA%A2.png" alt="删除黑-兄红"></p><p>Case2：兄弟为黑色，两个侄子也都是黑色；此时父亲红黑都可以</p><p>（1）将兄弟变为红色，X指向父节点，继续调整（对父节点及以上进行调整）</p><p><img src="https://raw.githubusercontent.com/RedamancyYou/BlogPic/main/%E5%88%A0%E9%99%A4%E4%BE%84%E9%BB%91%E5%85%84%E7%BA%A2.png" alt="删除侄黑兄红"></p><p>Case3：兄弟为黑色，右侄子为黑色，左侄子为红色；父节点红黑都可以</p><p>（1）将左侄子变成黑色，兄弟变为红色；这时，以兄弟为起点的右子树黑色高度下降</p><p>（2）将兄弟节点右旋，以恢复右子树的黑色高度；这时，左侄子成为新的右兄弟</p><p><img src="https://raw.githubusercontent.com/RedamancyYou/BlogPic/main/%E5%85%84%E9%BB%91%E5%8F%B3%E4%BE%84%E5%AD%90%E9%BB%91%E5%B7%A6%E4%BE%84%E5%AD%90%E7%BA%A2.png" alt="兄黑右侄子黑左侄子红"></p><p>Case4：兄弟为黑色，右侄子为红色；父节点和左侄子红黑都可以</p><p>（1）兄弟颜色改为与父节点一致，右侄子和父节点都变为黑色</p><p>（2）为了保证父节点变黑后，不影响所有路径的黑色高度，需要将父节点左旋</p><p>（3）X指向树的根节点，退出循环</p><p><img src="https://raw.githubusercontent.com/RedamancyYou/BlogPic/main/%E5%88%A0%E9%99%A4%E9%BB%91%E5%85%84%E5%8F%B3%E4%BE%84%E5%AD%90%E7%BA%A2.png" alt="删除黑兄右侄子红"></p><p>注意：替换节点是父节点的右儿子时，完全对称操作</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL</title>
      <link href="/2022/10/27/MySQL/"/>
      <url>/2022/10/27/MySQL/</url>
      
        <content type="html"><![CDATA[<h2 id="1-基础"><a href="#1-基础" class="headerlink" title="1.基础"></a>1.基础</h2><h3 id="1-1-MySQL有哪些数据类型"><a href="#1-1-MySQL有哪些数据类型" class="headerlink" title="1.1 MySQL有哪些数据类型"></a>1.1 MySQL有哪些数据类型</h3><blockquote><p>数值类型</p></blockquote><ol><li><p>整数类型</p><p>按字节数从小到大分别是TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT，分别占1、2、3、4、8字节</p><p>1）任何整数类型都可以加上UNSIGNED熟悉，表示无符号类型</p><p>2）任何整数类型都可以指定长度，如INT(4)，但是不会限制数据的合法长度，只是控制显示长度</p></li><li><p>小数类型</p><p>FLOAT、DOUBLE、DEMICAL</p></li></ol><blockquote><p>字符类型</p></blockquote><p>包括VARCHAR、CHAR、BLOB、TEXT</p><p>1）VARCHAR和CHAR可以指定<strong>字符</strong>长度，不是字节长度哦！！</p><blockquote><p>日期类型</p></blockquote><p>DATE、DATETIME、TIMESTAMP</p><p>1）DATE表示只能表示日期，DATETIME和TIMESTAMP可以表示日期和时间</p><p>2）DATETIME和TIMESTAMP的区别在于范围不同，DATETIME可以表示的时间从1000-01-01 00:00:00到9999-12-21 23:59:59，而TIMESTAMP可以的表示的时间从1970-01-01 00:00:01 UTC 到 2038-01-19 03:14:07 UTC。另外TIMESTAMP存储的格式是UTC格式，存储的是时间戳(一串数字)存储效率更高，占用空间更少。</p><h3 id="1-2-VARCHAR和CHAR的区别"><a href="#1-2-VARCHAR和CHAR的区别" class="headerlink" title="1.2 VARCHAR和CHAR的区别"></a>1.2 VARCHAR和CHAR的区别</h3><ol><li>VARCHAR是变长，CHAR是定长，比如VARCHAR(10)和CHAR(10)当都存入”Java”这四个字符时，VARCHAR的实际长度就是4，而CHAR的实际长度是10，”Java”字符的后面填充了6个空格</li><li>在存储上，CHAR对英文字符(ASCII)占用1个字节，对一个汉字使用2字节，而VARCHAR对每个字符均占2字节</li></ol><p>其他知识点：</p><p>1）VARCHAR在存储时，会使用1-2字节来表示存储的字符长度，字符长度在0-255之间，使用1字节表示，在256-65535之间使用2字节表示</p><p>2）VARCHAR字符的长度与统一行(row)的其他非大字段的字符加起来不能超过65535个字符</p><h3 id="1-3-如何选择VARCHAR和CHAR"><a href="#1-3-如何选择VARCHAR和CHAR" class="headerlink" title="1.3 如何选择VARCHAR和CHAR"></a>1.3 如何选择VARCHAR和CHAR</h3><ol><li>长度固定不变的使用CHAR，如学号、编号、身份证等信息</li><li>长度变化不大的使用CHAR，比如某个字段的长度都在90-100之间</li><li>十分频繁改变的使用CHAR</li></ol><h2 id="2-数据库设计"><a href="#2-数据库设计" class="headerlink" title="2.数据库设计"></a>2.数据库设计</h2><h3 id="2-1-什么是三大范式"><a href="#2-1-什么是三大范式" class="headerlink" title="2.1 什么是三大范式"></a>2.1 什么是三大范式</h3><ol><li>第一范式：字段(或属性)是不可分割的最小单元，不会有重复的列，体现原子性</li><li>第二范式：在满足1NF的前提下，存在一个候选码，非主属性全部依赖该候选码，即存在主键，不存在部分函数依赖</li><li>第三范式：在满足2NF的前提下，非主属性必须互不依赖，消除传递依赖</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> service(</span><br><span class="line">ip <span class="type">varchar</span>(<span class="number">15</span>),</span><br><span class="line">port <span class="type">char</span>(<span class="number">5</span>),</span><br><span class="line">service_id <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">unique</span>,</span><br><span class="line">service_name <span class="type">varchar</span>(<span class="number">10</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line"><span class="keyword">primary</span> key(ip,port)</span><br><span class="line">);</span><br><span class="line">主键：ip<span class="operator">+</span>port<span class="comment">---&gt;只有一个</span></span><br><span class="line">候选键：&#123;ip,port&#125;、&#123;service_id&#125;<span class="comment">---&gt;能够唯一标识一条记录的字段或字段集</span></span><br><span class="line">超键太多不列举！只要有ip<span class="operator">+</span>port或者service_id的字段集合就是超键<span class="comment">---&gt;一定存在候选键中的一个</span></span><br></pre></td></tr></table></figure><p>主属性：如果一个属性是构成一个候选键的属性集中的其中一个属性，这个属性就是主属性，反之则是非主属性</p><p>函数依赖：分析的是<strong>非主属性</strong>对<strong>主键</strong>的依赖关系</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">假设存在关系:</span><br><span class="line">R(学号，姓名，性别，班级，班主任，课程号，课程名，学时数，成绩)</span><br><span class="line">主键：学号+课程号（这是一个复合主键）</span><br><span class="line">候选键：&#123;学号,课程号&#125;</span><br><span class="line">主属性：学号、课程号 //只是这里刚好主键中的主属性和主属性一样了，主属性中还有其他候选键中的属性，只是这里候选键内容等于主键！</span><br><span class="line">非主属性有：&#123;姓名，性别，班级，班主任，课程名，学时数，成绩&#125;</span><br><span class="line"></span><br><span class="line">1. 成绩依赖于学号和课程号两个字段的组合；但只知道学号无法确定成绩，同理只知道课程号也无法确定成绩；</span><br><span class="line">只有学号和课程号组合在一起才能标识哪个学生哪门课程的成绩；</span><br><span class="line">因此（学号，课程号）----&gt;成绩  是“完全函数依赖”。</span><br><span class="line"></span><br><span class="line">2. 由于姓名、性别和班级三个属性只依赖于主键中的学号，与主键中的&#x27;课程号&#x27;无关。</span><br><span class="line">因此（学号，课程号）----&gt;姓名是“部分函数依赖”</span><br><span class="line">（学号，课程号）----&gt;性别是“部分函数依赖”</span><br><span class="line">（学号，课程号）-----&gt;班级是“部分函数依赖”</span><br><span class="line">3. 由于课程名和学时数只依赖于课程号，与主键中的&#x27;学号&#x27;无关</span><br><span class="line">因此（学号，课程号）-----&gt;课程名（或学时数）是“部分函数依赖”</span><br><span class="line">4. 班主任依赖于班级，与学号无关，与课程号也无关</span><br><span class="line">又因班级依赖于学号所以班主任间接依赖于学号</span><br><span class="line">因此，（学号，课程号）-----&gt;班主任是&#x27;传递函数依赖&#x27;</span><br></pre></td></tr></table></figure><h2 id="3-索引"><a href="#3-索引" class="headerlink" title="3.索引"></a>3.索引</h2><h3 id="3-1-索引的分类"><a href="#3-1-索引的分类" class="headerlink" title="3.1 索引的分类"></a>3.1 索引的分类</h3><blockquote><p>物理结构上</p></blockquote><ol><li>聚簇索引：又叫主键索引，每张表只有一个聚簇索引，聚簇索引的叶子节点直接存储对应记录的内存地址，可以通过内存地址找到相应行的数据。</li><li>非聚簇索引：在非聚簇索引叶子节点上存储的并不是真正的行数据，而是主键id，所以当我们使用非聚簇索引查询时，首先会得到一个主键id，然后再使用主键id去聚簇索引上找到真正的数据，并把这个过程叫做<strong>回表查询</strong></li></ol><blockquote><p>应用上</p></blockquote><ol><li>普通索引：MySQL中的基本索引类型，没有什么限制，允许在定义索引的列中插入重复值和空值，纯粹为了提高查询效率。通过<code>ALTER TABLE table_name ADD INDEX_NAME(column)</code>创建指定column的索引。</li><li>唯一索引：索引列中的值必须是唯一的，但是允许为空值。通过<code>ALTER TABLE table_name ADD UNIQUE index_name(column)</code>创建。</li><li>主键索引：特殊的唯一索引，也成聚簇索引，不允许有空值，并由数据库帮我们自动创建。</li><li>组合索引：组合表中多个字段创建的索引，遵守最左前缀匹配规则。</li><li>全文索引：只有在 MyISAM 引擎上才能使用，同时只支持 CHAR、VARCHAR、TEXT 类型字段上使用。</li></ol><h3 id="3-2-索引的优缺点"><a href="#3-2-索引的优缺点" class="headerlink" title="3.2 索引的优缺点"></a>3.2 索引的优缺点</h3><blockquote><p>优点</p></blockquote><p>通过创建索引可以大大提高系统的性能</p><ul><li>通过创建唯一性索引，可以保证数据库表中每行的数据的唯一性。</li><li>正确使用索引可以大大加快数据的检索速度，这也是创建索引的主要原因。</li><li>可以加速表和表之间的连接，特别是在实现数据的<strong>参考完整性</strong>方面特别有意义。</li><li>在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。</li></ul><p>数据完整性：实体完整性(每一行的数据是唯一的)、域(列)完整性(某个字段必须符合特定的约束，如not null等)、参照完整性(多表之间的设计，主要用于外键的设计)</p><h3 id="3-3-索引的设计原则"><a href="#3-3-索引的设计原则" class="headerlink" title="3.3 索引的设计原则"></a>3.3 索引的设计原则</h3><ol><li>唯一性原则，通过创建唯一性索引，可以加快检索的速度</li><li>为常作为查询条件的字段建立索引，因为该字段的查询速度回影响整个表的查询速度</li><li>为经常需要排序、分组和联合操作的字段建立索引</li><li>限制索引的数量，不宜建过多的索引</li><li>尽量使用数据量小的索引，如果索引值很长，会影响查询速度，此时应该使用前缀索引<ul><li>因为索引会</li></ul></li></ol><h2 id="数据库基础知识"><a href="#数据库基础知识" class="headerlink" title="数据库基础知识"></a>数据库基础知识</h2><h3 id="几个概念"><a href="#几个概念" class="headerlink" title="几个概念"></a>几个概念</h3><ol><li>元祖：数据库表中的每条记录就是一个元祖，是关系型数据库中的基本概念。</li><li>码：能唯一标识实体的属性就是码，对应表中的列。</li><li>候选码：某一属性或某一组属性能够唯一标识一个元祖，而其任何子集都不可以唯一标识，则该属性组为候选码</li><li>主码：也叫主键，主码是从候选码中选出来的，一张表最多只能有一个主码，但可以有多个候选码。</li><li>外码：也叫外键，如果一个关系中的一个属性是另一个关系中的主码，则这个属性为外码。</li><li>主属性：候选码中出现过的属性</li><li>非主属性：候选码中没有出现过的属性</li><li>函数依赖：若在一张表中，在属性（或属性组）X 的值确定的情况下，必定能确定属性 Y 的值，那么就可以说 Y 函数依赖于 X，写作 X → Y</li><li>部分函数依赖：如果 X→Y，并且存在 X 的一个真子集 X0，使得 X0→Y，则称 Y 对 X 部分函数依赖。比如学生基本信息表 R 中（学号，身份证号，姓名）当然学号属性取值是唯一的，在 R 关系中，（学号，身份证号）-&gt;（姓名），（学号）-&gt;（姓名），（身份证号）-&gt;（姓名）；所以姓名部分函数依赖与（学号，身份证号）；</li><li>完全函数依赖：在一个关系中，若某个非主属性数据项依赖于全部关键字称之为完全函数依赖。比如学生基本信息表 R（学号，班级，姓名）假设不同的班级学号有相同的，班级内学号不能相同，在 R 关系中，（学号，班级）-&gt;（姓名），但是（学号）-&gt;(姓名)不成立，（班级）-&gt;(姓名)不成立，所以姓名完全函数依赖与（学号，班级）；</li><li>传递函数依赖：在关系模式 R(U)中，设 X，Y，Z 是 U 的不同的属性子集，如果 X 确定 Y、Y 确定 Z，且有 X 不包含 Y，Y 不确定 X，（X∪Y）∩Z&#x3D;空集合，则称 Z 传递函数依赖(transitive functional dependency) 于 X。传递函数依赖会导致数据冗余和异常。传递函数依赖的 Y 和 Z 子集往往同属于某一个事物，因此可将其合并放到一个表中。比如在关系 R(学号 , 姓名, 系名，系主任)中，学号 → 系名，系名 → 系主任，所以存在非主属性系主任对于学号的传递函数依赖。。</li></ol><h3 id="主键和外键的区别"><a href="#主键和外键的区别" class="headerlink" title="主键和外键的区别"></a>主键和外键的区别</h3><p>（1）主键是用于唯一标识一个元组，不能有重复，不允许为空，一个表只能有一个主键</p><p>（2）外键是用于和其他表建立链接的，外键是另一张表的主键，外键是可以有重复的，也可以为空，一张表可以有多个外建</p><h3 id="为什么不推荐使用外键与级联"><a href="#为什么不推荐使用外键与级联" class="headerlink" title="为什么不推荐使用外键与级联"></a>为什么不推荐使用外键与级联</h3><p>首先使用外键与级联有一定的好处</p><ol><li>保证数据的一致性和完整性</li><li>级联操作方便，减轻了程序代码负担</li></ol><p>如果系统不涉及分库分表，并发量不是很高的情况下，可以考虑使用外键</p><p>不推荐使用的原因</p><blockquote><p>性能问题</p></blockquote><p>对于需要频繁插入的表，如果存在外键，每次插入都要去另一张表中判断该外键是否存在。在级联删除或更新时，逐行进行外键检查，会比批量删除或修改更慢。</p><blockquote><p>并发问题</p></blockquote><p>使用外键的情况下，每次修改数据都需要去另外一个表检查数据，需要获取额外的锁（锁定相关表的数据行，以保证修改前该数据行不会被其他事务修改或删除）。若是在并发大流量事务中容易发生死锁</p><blockquote><p>技术问题</p></blockquote><p>使用外键，其实就是将应用程序应该执行的判断逻辑转移到了数据库上，数据库的性能开销变大，如果判断在应用程序上的话，可以通过加机器做水平拓展</p><blockquote><p>扩展性问题</p></blockquote><ul><li>做平台迁移方便，比如从<code>MySQL</code>迁移到Oracle，像触发器、外键都可以利用框架本身的特性来实现，而不是依赖数据库的特性，做迁移更加方便。</li><li>分表分库方便，在水平拆分和分库的情况下，外键是无法生效的。将数据间的关系维护，放入应用程序中，为将来的分库分表省去很多麻烦。</li></ul><h3 id="什么是ER图"><a href="#什么是ER图" class="headerlink" title="什么是ER图"></a>什么是ER图</h3><p>实体联系图，提供了表示实体类型、属性和联系的方法，用来描述现实世界的概念模型</p><h3 id="什么是数据库范式"><a href="#什么是数据库范式" class="headerlink" title="什么是数据库范式"></a>什么是数据库范式</h3><p>1NF：属性不能再被分割，也就是这个字段只能是一个值，不能再被分割为其他多个字段。1NF是所有关系型数据库的最基本的要求</p><p>2NF：在1NF的基础上，消除了非主属性对码的部分函数依赖。第二范式在第一范式的基础上增加了一个列，这个列称为主键，非主属性都依赖于主键</p><p>3NF：在 2NF 的基础之上，消除了非主属性对于码的传递函数依赖 。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC2</title>
      <link href="/2022/09/29/JUC2/"/>
      <url>/2022/09/29/JUC2/</url>
      
        <content type="html"><![CDATA[<h2 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h2><h3 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h3><p> <img src="/../img/contentImg/image-20220929132813178.png" alt="image-20220929132813178"></p><p>Future接口可以为主线程开一个分支任务，专门为主线程处理耗时和费力的复杂业务</p><p><img src="/../img/contentImg/image-20220929133147058.png" alt="image-20220929133147058"></p><p>线程：thread  异步：future 返回：callable</p><p>Future优点：future+线程池异步多线程任务配合，能显著提高程序运行效率</p><p>案例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> CompletableFuture;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FutureTaskDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">        FutureTask&lt;String&gt; task1 = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">200</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;task1&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        FutureTask&lt;String&gt; task2 = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">300</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;task2&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        FutureTask&lt;String&gt; task3 = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;task3&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">        threadPool.execute(task1);</span><br><span class="line">        threadPool.execute(task2);</span><br><span class="line">        threadPool.execute(task3);</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">        System.out.println(<span class="string">&quot;程序运行时间：&quot;</span> + (end - start) + <span class="string">&quot;纳秒&quot;</span>);</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Future缺点：</p><ul><li><p>get()方法会阻塞线程，直到结果返回，一般建议放在程序后面</p></li><li><p>isDone轮询的方式会消耗CPU资源，且也不一定能及时的得到计算结果，如果想要异步获取结果，通常会以轮询的方式去获取结果，尽量不直接使用get阻塞</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> CompletableFuture;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FutureTaskDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        FutureTask&lt;String&gt; task = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;task come in ， waiting complete&quot;</span>);</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;take over&quot;</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(task).start();</span><br><span class="line">        System.out.println(<span class="string">&quot;main线程 ，忙其他任务&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (task.isDone())&#123;</span><br><span class="line">                System.out.println(task.get());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;目前任务还未完成&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>Future对于结果的获取不是很友好，只能通过阻塞或轮询的方式得到任务的结果。</p><p>Future无法完成复杂业务，回调通知（任务完成的时候告诉我）</p><h3 id="CompletableFuture-1"><a href="#CompletableFuture-1" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h3><p>CompletableFuture提供了一种观察者模式类似的机制，可以让任务执行完成后通知监听的一方。</p><p><img src="/../img/contentImg/image-20220929143126514.png" alt="image-20220929143126514"></p><p><img src="/../img/contentImg/image-20220929143243858.png" alt="image-20220929143243858"></p><blockquote><p> 创建CompletableFuture异步任务方式</p></blockquote><ol><li>无返回值<ul><li>自定义线程池：runAsync(Runnable task, Executor executor)</li><li>接口提供的ForkJoinPool线程池：runAsync(Runnable task, Executor executor)</li></ul></li><li>有返回值<ul><li>子定义线程池：supplyAsync(Runnable task, Executor executor)</li><li>接口提供的ForkJoinPool线程池：supplyAsync(Runnable task, Executor executor)</li></ul></li></ol><blockquote><p>增强的地方</p></blockquote><ol><li>对比Future，它减少阻塞和轮询</li><li>可以传入回调对象，当异步任务完成或者发生异常时，自动调用回调对象的方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> CompletableFuture;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompletableDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">        CompletableFuture&lt;Integer&gt; task = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> ThreadLocalRandom.current().nextInt(<span class="number">10</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;生成随机数：&quot;</span> + result);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (result &gt;= <span class="number">5</span>)&#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> result/<span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;, threadPool).whenComplete((v,e) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (e == <span class="literal">null</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;任务完成，得到的结果为：&quot;</span> + v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).exceptionally(e -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;出现异常：&quot;</span> + e.getCause() + <span class="string">&quot; ---&gt; &quot;</span> + e.getMessage());</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">&quot;main线程处理其他任务&quot;</span>);</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>函数式接口</p></blockquote><p><img src="/../img%5CcontentImg%5Cimage-20220929152826606.png" alt="image-20220929152826606"></p><blockquote><p>get和join方法区别</p></blockquote><p>都是得到返回值，get方法会抛出异常，join方法不抛异常。编译时是否抛出检查型异常</p><blockquote><p>案例</p></blockquote><p><img src="/../img%5CcontentImg%5Cimage-20220929153417990.png" alt="image-20220929153417990"></p><p>方式一：step by step</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> CompletableFuture;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从各大电商平台搜索一本书的价格</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> List&lt;NetMall&gt; malls = Arrays.asList(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">NetMall</span>(<span class="string">&quot;京东&quot;</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">NetMall</span>(<span class="string">&quot;淘宝&quot;</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">NetMall</span>(<span class="string">&quot;当当&quot;</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">NetMall</span>(<span class="string">&quot;百度&quot;</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">NetMall</span>(<span class="string">&quot;臭鱼&quot;</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">NetMall</span>(<span class="string">&quot;找靓书&quot;</span>)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        List&lt;String&gt; mysql = getPrice(malls, <span class="string">&quot;mysql&quot;</span>);</span><br><span class="line">        mysql.forEach(System.out::println);</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(end - start);</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">start2</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        List&lt;String&gt; mysql2 = getPriceByCompletable(malls, <span class="string">&quot;mysql&quot;</span>);</span><br><span class="line">        mysql2.forEach(System.out::println);</span><br><span class="line">        <span class="type">long</span> <span class="variable">end2</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(end2 - start2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 并发查询</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> malls</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bookName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">getPriceByCompletable</span><span class="params">(List&lt;NetMall&gt; malls, String bookName)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> malls</span><br><span class="line">                .stream()</span><br><span class="line">                .map(mall -&gt; CompletableFuture.supplyAsync(() -&gt; String.format(bookName + <span class="string">&quot;在 %s 的价格是 %.2f&quot;</span>, mall.getName(), mall.getPrice())))</span><br><span class="line">                .collect(Collectors.toList())</span><br><span class="line">                .stream()</span><br><span class="line">                .map((task) -&gt; task.join()).collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * step by step 依次按序查询</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> malls</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bookName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">getPrice</span><span class="params">(List&lt;NetMall&gt; malls, String bookName)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> malls</span><br><span class="line">                .stream()</span><br><span class="line">                .map(mall -&gt; String.format(bookName + <span class="string">&quot;在 %s 的价格是 %.2f&quot;</span>, mall.getName(), mall.getPrice()))</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NetMall</span> &#123;</span><br><span class="line">    <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NetMall</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name; <span class="comment">// 电商平台名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> price; <span class="comment">// 书的价格</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getPrice</span><span class="params">()</span> &#123;</span><br><span class="line">        price = random.nextDouble() + name.charAt(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql在 京东 的价格是 20140.54</span><br><span class="line">mysql在 淘宝 的价格是 28120.36</span><br><span class="line">mysql在 当当 的价格是 24403.20</span><br><span class="line">mysql在 百度 的价格是 30334.05</span><br><span class="line">mysql在 臭鱼 的价格是 33261.07</span><br><span class="line">mysql在 找靓书 的价格是 25214.78</span><br><span class="line">6135</span><br><span class="line">mysql在 京东 的价格是 20140.90</span><br><span class="line">mysql在 淘宝 的价格是 28120.60</span><br><span class="line">mysql在 当当 的价格是 24403.86</span><br><span class="line">mysql在 百度 的价格是 30334.29</span><br><span class="line">mysql在 臭鱼 的价格是 33261.02</span><br><span class="line">mysql在 找靓书 的价格是 25214.02</span><br><span class="line">1023</span><br></pre></td></tr></table></figure><p>当电商平台越多时，差距越明显</p><blockquote><p>CompletableFuture常用方法</p></blockquote><ol><li><p>获得结果和触发计算</p><ul><li><p>获取结果</p><ul><li>public T get()</li><li>public T get(long timeout, TimeUnit unit)</li><li>public T join()</li><li>public getNoew(T valueIfAbsent)</li></ul></li><li><p>主动触发计算</p><ul><li><p>public boolean complete(T value) 是否打断get方法立即返回value值</p><p>当成功打断时，join或get返回value，没有打断时，正常返回结果</p></li></ul></li></ul></li><li><p>对计算结果进行处理</p><ul><li>thenApply：计算结果存在依赖关系，这两个线程串行化，由于存在依赖关系，当前步骤有异常的花就叫停</li><li>handle：计算结果存在依赖关系，这两个线程串行化，，当前步骤有异常的继续下一步</li></ul></li><li><p>对计算结果进行消费</p><ul><li>接收任务的处理结果，并消费结果，没有返回值</li></ul></li><li><p>对计算速度进行选用</p><ul><li>applyToEither</li><li><img src="/../img%5CcontentImg%5Cimage-20220929184231351.png" alt="image-20220929184231351"></li></ul></li><li><p>对计算结果进行合并</p><ul><li>thenCombine：两个和CompletionStage任务都完成后，最终能把两个任务结果一起交给thenCombine来处理，先完成的等待其他分支任务</li><li><img src="/../img%5CcontentImg%5Cimage-20220929184633195.png" alt="image-20220929184633195"></li></ul></li></ol><p><img src="/../img%5CcontentImg%5Cimage-20220929183956326.png" alt="image-20220929183956326"></p><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="Synchronized介绍"><a href="#Synchronized介绍" class="headerlink" title="Synchronized介绍"></a>Synchronized介绍</h3><p>synchronized同步代码块：javap -c 反编译后是通过monitorcenterEnter和monitorCenterExit</p><p>synchronized普通同步方法：调用指令将会检查方法的ACC_SYNCHRONIZED访问标志是否被设置。如果设置了，执行线程会先持有monitor锁，然后再执行方法，最后方法完成后释放monitor（无论是正常完成还是非正常完成）</p><p>synchronized静态同步方法：ACC_STATIC，ACC_SYNCHRONIZED访问标志区分该方法是否是静态同步方法</p><blockquote><p>为什么任何一个对象都可以成为锁</p></blockquote><p><img src="/../img%5CcontentImg%5Cimage-20220929195508136.png" alt="image-20220929195508136"></p><p><img src="/../img%5CcontentImg%5Cimage-20220929195530791.png" alt="image-20220929195530791"></p><p>每个对象都带着一个对象监视器，每一个被锁住的对象都会和Monitor关联起来</p><h2 id="中断机制"><a href="#中断机制" class="headerlink" title="中断机制"></a>中断机制</h2><p><img src="/../img%5CcontentImg%5Cimage-20220929212347798.png" alt="image-20220929212347798"></p><p><img src="/../img%5CcontentImg%5Cimage-20220929212749814.png" alt="image-20220929212749814"></p><p>如何停止中断运行中的线程？</p><ol><li><p>通过标志位</p><p><img src="/../img%5CcontentImg%5Cimage-20220930091702226.png" alt="image-20220930091702226"></p></li><li><p>interrupt</p></li></ol><p><img src="/../img%5CcontentImg%5Cimage-20220930095200987.png" alt="image-20220930095200987"></p><p><img src="/../img%5CcontentImg%5Cimage-20220930213440785.png" alt="image-20220930213440785"></p><p>中断不活动的线程没有影响</p><p><img src="/../img%5CcontentImg%5Cimage-20221001103454212.png" alt="image-20221001103454212"></p><p><img src="/../img%5CcontentImg%5Cimage-20221001103659939.png" alt="image-20221001103659939"></p><h2 id="LockSupport"><a href="#LockSupport" class="headerlink" title="LockSupport"></a>LockSupport</h2><p><img src="/../img%5CcontentImg%5Cimage-20221001105509044.png" alt="image-20221001105509044"></p><p><img src="/../img%5CcontentImg%5Cimage-20221001105540156.png" alt="image-20221001105540156"></p><p><img src="/../img%5CcontentImg%5Cimage-20221001105936537.png" alt="image-20221001105936537"></p><p><img src="/../img%5CcontentImg%5Cimage-20221001105949330.png" alt="image-20221001105949330"></p><p><img src="/../img%5CcontentImg%5Cimage-20221001110830947.png" alt="image-20221001110830947"></p><p><img src="/../img%5CcontentImg%5Cimage-20221001111231887.png" alt="image-20221001111231887"></p><p><img src="/../img%5CcontentImg%5Cimage-20221001111316374.png" alt="image-20221001111316374"></p><h2 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h2><p><img src="/../img%5CcontentImg%5Cimage-20221001112216614.png" alt="image-20221001112216614"></p><p><img src="/../img%5CcontentImg%5Cimage-20221001151951557.png" alt="image-20221001151951557"></p><p><img src="/../img%5CcontentImg%5Cimage-20221001152256934.png" alt="image-20221001152256934"></p><p><img src="/../img%5CcontentImg%5Cimage-20221001153102196.png" alt="image-20221001153102196"></p><p><img src="/../img%5CcontentImg%5Cimage-20221001153314578.png" alt="image-20221001153314578"></p><p><img src="/../img%5CcontentImg%5Cimage-20221001153632722.png" alt="image-20221001153632722"></p><p><img src="/../img%5CcontentImg%5Cimage-20221003091629480.png" alt="image-20221003091629480"></p><h3 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h3><p><img src="/../img/contentImg/image-20221003092141835.png" alt="image-20221003092141835"></p><p><img src="/../img/contentImg/image-20221003092228479.png" alt="image-20221003092228479"></p><p><img src="/../img/contentImg/image-20221003092507429.png" alt="image-20221003092507429"></p><p><img src="/../img%5CcontentImg%5Cimage-20221003092934859.png" alt="image-20221003092934859"></p><p>传递</p><p><img src="/../img%5CcontentImg%5Cimage-20221003092951212.png" alt="image-20221003092951212"></p><p><img src="/../img%5CcontentImg%5Cimage-20221003093145006.png" alt="image-20221003093145006"></p><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>可见、有序</p><p><img src="/../img%5CcontentImg%5Cimage-20221003100027837.png" alt="image-20221003100027837"></p><h3 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h3><p>  <img src="/../img%5CcontentImg%5Cimage-20221004101813228.png" alt="image-20221004101813228"></p><p><img src="/../img%5CcontentImg%5Cimage-20221004101926766.png" alt="image-20221004101926766"></p><p><img src="/../img%5CcontentImg%5Cimage-20221004102246830.png" alt="image-20221004102246830"></p><p><img src="/../img%5CcontentImg%5Cimage-20221004102435493.png" alt="image-20221004102435493"></p><p><img src="/../img%5CcontentImg%5Cimage-20221004102830348.png" alt="image-20221004102830348"></p><p><img src="/../img%5CcontentImg%5Cimage-20221004103219155.png" alt="image-20221004103219155"></p><p><img src="/../img%5CcontentImg%5Cimage-20221004103712565.png" alt="image-20221004103712565"></p><p><img src="/../img%5CcontentImg%5Cimage-20221004103730511.png" alt="image-20221004103730511"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 高并发 </tag>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC</title>
      <link href="/2022/09/22/JUC/"/>
      <url>/2022/09/22/JUC/</url>
      
        <content type="html"><![CDATA[<h1 id="Java并发编程基础"><a href="#Java并发编程基础" class="headerlink" title="Java并发编程基础"></a>Java并发编程基础</h1><h2 id="并发编程线程基础"><a href="#并发编程线程基础" class="headerlink" title="并发编程线程基础"></a>并发编程线程基础</h2><h3 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h3><ol><li>并发<ul><li>是在同一实体上的多个事件</li><li>是在同一台处理器上“同时”处理多个任务</li><li>同一时刻，其实只有一个事件在发生</li></ul></li><li>并行<ul><li>是在不同实体上的多个事件</li><li>是在多台处理器上同时处理多个任务</li><li>同一时刻，有多个事件发生</li></ul></li></ol><h3 id="进程线程与管程"><a href="#进程线程与管程" class="headerlink" title="进程线程与管程"></a>进程线程与管程</h3><ol><li>进程：一个正在运行的程序就是一个进程，操作系统会给进程分配系统资源（如内存等）</li><li>线程：一个进程中包含1个或多个线程，操作系统中的CPU资源是被分配到线程中的，线程是CPU分配的基本单位</li><li>管程：也叫Monitor，就是锁的概念</li></ol><h3 id="线程创建与运行"><a href="#线程创建与运行" class="headerlink" title="线程创建与运行"></a>线程创建与运行</h3><p>三种方式：继承Thread类重写run方法、实现Runnable接口的run方法、使用FutureTask方式，前面两种较简单和常用，这里只介绍第三种方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FutureTaskDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建异步任务</span></span><br><span class="line">        FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">CallerTask</span>());</span><br><span class="line">        <span class="comment">// 启动线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 等待任务执行完毕返回结果</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> futureTask.get();</span><br><span class="line">            System.out.println(res);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (ExecutionException | InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建任务类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CallerTask</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt;&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Thread.sleep(<span class="number">3000L</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优势：既可以像实现Runnable接口方式继承其他类之外，还可以拥有线程的返回结果。</p><blockquote><p>注意</p></blockquote><p>线程在调用start方法后，只是启动了线程，此时线程并不一定马上执行，而是处于就绪状态（Runnable状态），此时他已经获取了除了CPU资源外的其他资源，等待获取CPU资源后才会正真处于运行状态（Running状态）</p><h3 id="线程通知与等待"><a href="#线程通知与等待" class="headerlink" title="线程通知与等待"></a>线程通知与等待</h3><p>当一个线程调用一个共享变量的wait()方法时，该线程会被挂起处于等待状态（Wait状态），直到发生下面几个事件</p><ol><li>其他线程调用了<strong>该共享对象</strong>的notify()方法或者notifyAll()方法</li><li>其他线程调用<strong>该线程</strong>的interrupt()方法，该线程抛出InterruptedException异常返回</li></ol><p>如果一个对象没有被某个线程获得到监视器锁，如果这时调用该对象的wait方法则会抛出IllegalMonitorStateException</p><blockquote><p>虚假唤醒</p></blockquote><p>一个处于挂起状态的线程没有被其它线程使用notify、notifyAll方法唤醒，就转为了可运行状态（Runnable）</p><p>解决方法：在一个循环中调用wait方法进行防范，退出循环的条件是满足了唤醒该线程的条件。</p><p>生产消费模型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> chapter01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProducerConsumer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Queue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Queue</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Producer</span>(queue).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Consumer</span>(queue).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Queue</span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">maxSize</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Producer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Queue queue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Producer</span><span class="params">(Queue queue)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span>  <span class="title function_">produce</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (queue)&#123;</span><br><span class="line">            <span class="comment">// 产品已经装满，不可以再生产了</span></span><br><span class="line">            <span class="keyword">while</span> (queue.size &gt;= queue.maxSize)&#123;</span><br><span class="line">                <span class="comment">// 挂起生产线程</span></span><br><span class="line">                queue.wait();</span><br><span class="line">            &#125;</span><br><span class="line">            queue.size++; <span class="comment">// 生产产品</span></span><br><span class="line">            System.out.println(<span class="string">&quot;产品&quot;</span> + queue.size +<span class="string">&quot;生产完毕&quot;</span>);</span><br><span class="line">            queue.notifyAll(); <span class="comment">// 通知消费线程可以消费</span></span><br><span class="line">            Thread.sleep(<span class="number">100L</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">                produce();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Queue queue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Consumer</span><span class="params">(Queue queue)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">consume</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (queue)&#123;</span><br><span class="line">            <span class="comment">// 产品队列中无产品，不可以消费</span></span><br><span class="line">            <span class="keyword">while</span> (queue.size &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">                queue.wait();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;产品&quot;</span>+queue.size+<span class="string">&quot;被消费了&quot;</span>);</span><br><span class="line">            queue.size--; <span class="comment">// 消费产品</span></span><br><span class="line">            queue.notifyAll(); <span class="comment">// 通知生产线程，可以生产</span></span><br><span class="line">            Thread.sleep(<span class="number">100L</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">                consume();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Tip：如果一个线程获取了两个监视器锁，只调用类其中一个对象的wait方法，那么该线程只会释放该对象的锁，并不会释放其他锁。</p><blockquote><p>notify方法</p></blockquote><ul><li>一个线程调用共享对象的notify方法后，会唤醒一个在该共享变量上调用wait系列方法后被挂起的线程。一个共享变量上可能会有多个线程等待，具体唤醒哪个等待的线程是随机的。</li><li>被唤醒的线程也不一定会获取到共享对象的监视器锁，这是因为该线程还需要和其他线程一起竞争该锁，只有该线程竞争到了共享变量的监视器锁后才可以继续执行。</li><li>类似wait方法，只有放前线程获取到了共享变量的监视器锁后，才可以调用共享变量的notify方法，否则抛出IllegalMonitorStateException异常</li><li>notify方法只会唤醒一个等待线程，被唤醒的线程结束后，如果不唤醒其他线程，那么其他线程将一直处于Wait状态</li><li>notifyAll方法会唤醒所有等待共享变量的线程，一个线程执行完成后，另一个被唤醒的线程接着执行。</li><li>notifyAll方法，只会唤醒调用这个方法前调用了wait系列函数而被放入共享变量等待集合里面的线程，如果实在调用notifyAll方法后调用wait系列而阻塞挂起的线程不会被唤醒。</li></ul><blockquote><p>join方法</p></blockquote><ul><li>join方法不是Object中的方法，而是Thread类中的方法</li><li>join方法的作用是等待线程执行终止：在一个线程中，调用另一个线程的join方法时，会阻塞当前线程，直到另一个线程执行完毕。</li><li>当线程A调用线程B的join方法时，线程A会被阻塞，此时如果有其他线程调用A线程的interrupt方法时，会抛出InterruptedException</li></ul><blockquote><p>sleep方法</p></blockquote><p>当一个线程执行Thread.sleep()方法后，该线程会暂时让出指定时间的执行权，也就是这期间不参与CPU的调度，但是该线程所拥有的监视器资源，比如锁还是持有不让出的。指定的时间到达后，函数会正常返回，线程就处于就绪状态，然后参与CPU的调度，获取到CPU资源后就可以继续运行了。如果在睡眠期间其他线程调用了该线程的interrupt方法中断该线程，则会抛出InterruptedException</p><blockquote><p>yield方法</p></blockquote><p>当一个线程调用yield方法时，当前线程会让出CPU使用权，然后处于就绪状态，线程调度器会从线程就绪队列中获取一个线程优先级最高的线程，当然也有可能会调度到刚刚让出CPU的那个线程来获取CPU执行权。</p><p>yield和sleep方法的区别：</p><p>sleep与yield方法的区别在于，当线程调用sleep方法时，线程会被阻塞挂起指定的时间，在这期间线程调度器不会去调度该线程。而调用yield方法，线程只是让出自己剩余的时间片，并没有被阻塞挂起，而是处于就绪状态，线程调度器下一次调度时就有可能调度到该当前线程执行。</p><blockquote><p>线程中断</p></blockquote><ol><li>void interrupt()：中断线程，例如，当线程A运行时，线程B可以调用线程A的interrupt方法来设置线程A的中断标志为true并立即返回。设置标志仅仅是设置标志，线程A并没有中断，它会继续往下执行。如果线程A处于阻塞挂起状态，调用interrupt后会抛出InterruptedException异常</li><li>boolean isInterrupted()：检测当前线程是否被中断，如果是返回true，否则返回false。</li><li>boolean Thread.interrupted()：Thread类的静态方法，判断调用线程是否被中断，哪个线程调用，判断哪个线程。如果发现当前线程被中断，则会清除中断标志 （false）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterruptDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 如果当前线程中断，则退出循环</span></span><br><span class="line">            <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot; hello&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 启动子线程</span></span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="comment">// 主线程休眠1s以便让子线程输出</span></span><br><span class="line">        Thread.sleep(<span class="number">500L</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;主线程中断子线程&quot;</span>);</span><br><span class="line">        <span class="comment">// 中断子线程</span></span><br><span class="line">        thread.interrupt();</span><br><span class="line">        <span class="comment">// 等待子线程执行完毕</span></span><br><span class="line">        thread.join();</span><br><span class="line">        System.out.println(<span class="string">&quot;主线程结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程死锁"><a href="#线程死锁" class="headerlink" title="线程死锁"></a>线程死锁</h3><p>死锁的四个条件</p><ol><li>互斥条件：资源排他性，该资源同一时刻只能由一个线程占用</li><li>请求并持有条件：已经有了至少一个资源，但又提出新的资源请求，而该资源又被其他线程占有，所以导致该线程阻塞</li><li>不可剥夺条件：指线程获取到的资源在自己使用完成之前不被其他线程抢占。</li><li>环路等条件：发生死锁时e，必然存在一个线程-资源的环形链。</li></ol><p>如何避免资源死锁：使用资源申请的有序性原则。只有在拥有前一个资源后，才可以申请下一个资源，每个线程都这样。对资源排序</p><h3 id="守护线程与用户线程"><a href="#守护线程与用户线程" class="headerlink" title="守护线程与用户线程"></a>守护线程与用户线程</h3><p>守护线程和用户线程的区别之一就是：JVM必须等到所有的用户线程执行完毕后才会退出，而不会在乎守护线程是否结束。</p><h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p>简介：ThreadLocal提供了线程本地变量，也就是如果创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的一个本地副本。当多个线程操作这个变量时，实际操作的时自己本地内存里面的变量，从而避免了线程安全问题。</p><blockquote><p>使用方法</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalDemo</span> &#123;</span><br><span class="line">    <span class="comment">// 创建ThreadLocal变量</span></span><br><span class="line">    <span class="keyword">static</span> ThreadLocal&lt;String&gt; localVariable = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadOne</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 设置threadOne 中localVariable的值</span></span><br><span class="line">            localVariable.set(<span class="string">&quot;threadOne local variable&quot;</span>);</span><br><span class="line">            print(<span class="string">&quot;threadOne&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;threadOne remove after: &quot;</span> + localVariable.get());</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadTwo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 设置threadTwo 中localVariable的值</span></span><br><span class="line">            localVariable.set(<span class="string">&quot;threadTwo local variable&quot;</span>);</span><br><span class="line">            print(<span class="string">&quot;threadTwo&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;threadTwo remove after: &quot;</span> + localVariable.get());</span><br><span class="line">        &#125;);</span><br><span class="line">        threadOne.start();</span><br><span class="line">        threadTwo.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String str)</span>&#123;</span><br><span class="line">        <span class="comment">// 打印当前线程本地内存中localVariable变量的值</span></span><br><span class="line">        System.out.println(str + <span class="string">&quot;:&quot;</span> + localVariable.get());</span><br><span class="line">        <span class="comment">// 清除当前线程本地内存中的localVariable变量</span></span><br><span class="line">        <span class="comment">// localVariable.remove();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">threadTwo:threadTwo local variable</span><br><span class="line">threadTwo remove after: threadTwo local variable</span><br><span class="line">threadOne:threadOne local variable</span><br><span class="line">threadOne remove after: threadOne local variable</span><br></pre></td></tr></table></figure><blockquote><p>ThreadLocal实现原理</p></blockquote><ul><li>Thread类中有一个threadLocals和一个inheritableThreadLocals属性，都是ThreadLocalMap类型的属性。默认情况下线程中着两个属性都为null，只有当线程第一次调用ThreadLocal的set或者是get方法时，才会创建它们。</li><li>其实每个线程的本地变量不是存放在ThreadLocal实例里面，而是存放在调用线程的threadLocals变量里面</li><li>ThreadLocal就是一个空壳，它通过set方法把value值放入调用线程的threadLocals变量里面，当调用ThreadLocal的get方法时，再从线程的threadLocals变量里面将其拿出来再使用。</li><li>一个线程可能与多个ThreadLocal关联</li><li>threadLocals变量的key是ThreadLcoal类型，值是一个泛型，一个ThreadLocal只能存放一个数据。一个线程可以有多个ThreadLocal</li></ul><blockquote><p>ThreadLocal不足</p></blockquote><p>ThreadLocal不具备继承性，这里的继承是指，子线程无法访问父线程中的数据，解决方案就是InheritedThreadLocal</p><h3 id="InheritedThreadLocal"><a href="#InheritedThreadLocal" class="headerlink" title="InheritedThreadLocal"></a>InheritedThreadLocal</h3><ul><li>InheritedThreadLocal继承ThreadLocal类，并重写了ThreadLocal类中的getMap，createMap方法，让线程本地变量保存到inheritedThreadLocals变量中而而不是threadLocals变量中，线程在通过InheritedThreadLocal类实例的set或者get方法设置变量时，就会创建当前线程的inheritedThreadLocals变量。</li><li>当父线程创建子线程时，构造函数会把父线程中inheritedThreadLocals变量里面的本地变量复制一份保存到子线程的inheritedThreadLocals变量里面</li></ul><blockquote><p>适用场景</p></blockquote><ul><li>子线程需要使用存放在threadLocals变量中的用户登录信息。</li></ul><h2 id="并发编程其他基础知识"><a href="#并发编程其他基础知识" class="headerlink" title="并发编程其他基础知识"></a>并发编程其他基础知识</h2><h3 id="Java中共享变量的内存可见性问题"><a href="#Java中共享变量的内存可见性问题" class="headerlink" title="Java中共享变量的内存可见性问题"></a>Java中共享变量的内存可见性问题</h3><p><img src="/../img/contentImg/Java%E7%BA%BF%E7%A8%8B%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B-1664096073424.png" alt="Java线程内存模型"></p><p>Java内存模型规定，将所有的变量都存放在主内存中，当线程使用变量时，会把主内存里面的变量复制到自己的工作空间或者工作内存，线程读写变量时操作的是自己工作内存中的变量，处理完变量后，将变量值更新到主内存。</p><h3 id="CAS操作和Unsafe类"><a href="#CAS操作和Unsafe类" class="headerlink" title="CAS操作和Unsafe类"></a>CAS操作和Unsafe类</h3><p>CAS即Compare And Swap，是JDK提供的非阻塞原子性操作，它通过硬件保证了比较-更新操作的原子性。</p><p>Unsafe类提供了硬件级别的原子性操作，Unsafe类中的方法都是native方法，它们使用JNI的方式访问本地C++实现库。</p><h3 id="Synchronized关键字"><a href="#Synchronized关键字" class="headerlink" title="Synchronized关键字"></a>Synchronized关键字</h3><p>原子性内置锁，排他锁</p><p>Java中的线程和操作系统的原生线程一一对应，所以当阻塞一个线程时，需要从用户态切换到内核态执行阻塞操作，比较耗时，而Synchronized的使用就会导致上下文切换。</p><blockquote><p>synchronized内存语义</p></blockquote><p>进入synchronized块：把在synchronized块内使用到的变量从线程的工作内存中清除，这样在synchronized块内使用到该变量时就不会从线程的工作内存中获取，而是直接从主内存中获取。</p><p>推出synchronized：把synchronized块内对共享变量的修改刷新到主内存。</p><p>这样synchronized就可以解决共享变量的内存可见性</p><p>synchronized还可以用来实现原子性操作。</p><h3 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h3><p>volatile关键字也是用来解决共性变量内存可见性问题。</p><ul><li>volatile确保对一个变量的更新对其他线程马上可见。</li><li>当一个变量声明为volatile时，线程在写入变量时不会把值缓存在寄存器或者其他地方，而是会把值刷新回主内存。</li><li>线程读取该变量时，会从主内存重新获取最新值，而不是使用当前线程的工作内存中的值</li><li>volatile还可以避免指令重排带来的问题<ul><li>写volatile变量时，可以确保volatile写之前的操作不会被编译器重排序到volatile写之后</li><li>读volatile变量时，可以确保volatile读之后的操作不会被编译器重排序到volatile读之前</li></ul></li></ul><p>volatile虽然提供了可见性保证，但并不保证操作的原子性。</p><blockquote><p>使用场景</p></blockquote><ul><li>写入变量值不依赖变量的当前值时。因为如果依赖当前值，将是获取-计算-写入三步操作，这三步操作不是原子性的，而volatile不保证原子性。</li><li>读写变量值时没有加锁。</li></ul><h3 id="伪共享"><a href="#伪共享" class="headerlink" title="伪共享"></a>伪共享</h3><ul><li>为了解决计算机系统中主内存与CPU之间运行速度差问题，会在CPU与主内存之间添加一级或者多级告诉缓冲存储器（Cache）。这个Cache一般被继承到CPU内部，所以也叫CPU Cache</li><li>在Cache内部是按行存储的，其中每一行称为一个Cache行，Cache行是与主内存进行数据交换的单位，Cache行的大小一般为2的幂次数字节。</li><li>当CPU访问某个变量时，会先去看CPU Cache内是否有改变量，如果有则直接从中获取，否则就去主内存里面获取该变量，然后把该变量所在内存区域的一个<strong>Cache行大小的内存</strong>复制到Cache中。由于存放到Cache行的是内存块而不是单个变量，所以可能会把多个变量存放到同一个Cache行中。</li><li>当多个线程同时修改一个缓存行里面的多个变量时，同一时刻只能有一个线程操作缓存行。所以可能会导致线程去访问二级缓存或直接内存，导致性能下降。</li></ul><blockquote><p>如何避免伪共享</p></blockquote><ol><li>JDK8之前：字节填充，假设Cache行大小为64字节，定义一个int4字节后，可以定义15个int类型的填充变量</li><li>JDK8之后：在类或属性上使用@sun.misc.Contented注解<ul><li>该注解只用于Java核心类，如rt包下的类</li><li>如果用户类想要使用，需要添加JVM参数：-XX:-RestrictContented，填充的宽度默认为128字节，可以使用-XX:ContentedPaddingWidth进行设置</li></ul></li></ol><p>在多线程下访问同一个缓存行的多个变量时才会出现伪共享，在单线程下访问一个缓存行里面的多个变量反而会对程序运行起到加速作用。</p><h3 id="锁的概述"><a href="#锁的概述" class="headerlink" title="锁的概述"></a>锁的概述</h3><blockquote><p>乐观锁与悲观锁</p></blockquote><ol><li>乐观锁：<ul><li>悲观锁对数据被外界修改持保守态度，任务数据很容易被其他线程修改，所以在数据处理前都会对数据加锁。</li><li>悲观锁的实现依靠数据库提供的锁机制，在数据库中，在对数据记录操作前给记录加排他锁。</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">updateEntry</span><span class="params">(<span class="type">long</span> id)</span>&#123;</span><br><span class="line">    <span class="comment">// 从数据库中查询数据</span></span><br><span class="line">    <span class="type">EntryObject</span> <span class="variable">entry</span> <span class="operator">=</span> query(<span class="string">&quot;select * from table where id = #&#123;id&#125; for update&quot;</span>, id);  <span class="comment">//（1）</span></span><br><span class="line">    <span class="comment">// 修改数据</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> generateName(entry);</span><br><span class="line">    entry.setName(name); <span class="comment">// （2）</span></span><br><span class="line">    <span class="comment">// 更新数据到数据库中</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> update(<span class="string">&quot;update table set name = #&#123;name&#125;, age=#&#123;name&#125; where id = #&#123;id&#125;&quot;</span>, entry); <span class="comment">// （3）</span></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码，当多个线程同时调用updateEntry方法时，并且传递的是同一个id，只有一个线程执行代码（1）会成功，其他线程被阻塞，这是因为同一时间，只有一个线程可以获取对应记录的锁，在获取锁的线程释放锁之前（updateEntry执行完毕，提交事务前），其他线程必须等待，也就是同一时间只有一个线程可以对该记录进行修改。</p><ol start="2"><li>乐观锁：<ul><li>乐观锁认为数据一般情况下不会造成冲突，所以访问记录前不会加锁。</li><li>乐观锁会在数据提交更新时，对数据冲突与否进行检测。比如根据update返回的行数，再决定作何处理。</li><li>乐观锁不会使用数据库提供的锁机制，一般在表中添加version字段，或者使用业务状态来实现。</li><li>乐观锁直到提交时才锁定，所以不会产生人任何死锁。</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">updateEntry</span><span class="params">(<span class="type">long</span> id)</span>&#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">retryNum</span> <span class="operator">=</span> <span class="number">5</span>; <span class="comment">// 如果更新失败超过5次，就不再重试</span></span><br><span class="line">    <span class="keyword">while</span>(retryNum &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 使用乐观锁获取记录</span></span><br><span class="line">        <span class="type">EntryObject</span> <span class="variable">entry</span> <span class="operator">=</span> query(<span class="string">&quot;select * from table where id = #&#123;id&#125;&quot;</span>, id);</span><br><span class="line">        <span class="comment">// 修改记录数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> generateName(entry);</span><br><span class="line">        entry.setName(name);</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> update(<span class="string">&quot;update table set name = #&#123;name&#125;,age = #&#123;age&#125;,version = #&#123;version&#125;+1,where id = #&#123;id&#125; and version = #&#123;version&#125;&quot;</span>, entry);</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">1</span>)&#123;</span><br><span class="line">            result = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        retryNum--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>公平锁与非公平锁</p></blockquote><p>公平锁表示线程获取锁的顺序是按照线程请求锁的时间早晚来决定的，也就是最早请求锁的线程最早获取到锁</p><p>在没有公平性需求的前提下，尽量使用非公平锁。</p><blockquote><p>独占锁与共享锁</p></blockquote><ul><li>独占锁保证任何时候都只有一个线程能得到资源，ReetrantLock就是以独占方式实现的。共享锁则可以同时由多个线程持有，例如ReadWriteLock读写锁，它允许一个资源可以被多线程同时进行读操作。</li><li>独占锁是一种悲观锁，每次访问资源都要加上互斥锁。共享锁是一种乐观锁。</li></ul><blockquote><p>可重入锁</p></blockquote><p>允许一个线程再次再次获取它已经获取到的锁，叫做可重入锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">helloA</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">helloB</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello B&quot;</span>);</span><br><span class="line">        helloA();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码，调用helloB方法前会先获取内置锁，之后调用helloA，也是会先去获取锁，如果是不可重入锁，将会一直阻塞</p><p>synchronized内部锁是可重入锁，原理是锁内部维护一个线程标识，用来表示该锁目前被哪个线程占用，然后关联一个计数器。获取锁+1，释放锁-1，计数器为0时将表示重置为null。</p><blockquote><p>自旋锁</p></blockquote><p>获取锁失败后，不会马上阻塞，不放弃CPU资源，重新尝试（默认10次，-XX:PreBlockSpinsh参数设置）</p><p>自旋锁是使用CPU时间换取线程阻塞与调度的开销。</p><h1 id="Java并发编程高级篇"><a href="#Java并发编程高级篇" class="headerlink" title="Java并发编程高级篇"></a>Java并发编程高级篇</h1><h2 id="ThreadLocalRandom解析"><a href="#ThreadLocalRandom解析" class="headerlink" title="ThreadLocalRandom解析"></a>ThreadLocalRandom解析</h2><h3 id="Random类局限性"><a href="#Random类局限性" class="headerlink" title="Random类局限性"></a>Random类局限性</h3><p>在多线程下使用单个Random实例生成随机数时，当多个线程同时计算随机数来计算新的种子时，多个线程会竞争同一个原子变量的更新操作，由于是CAS操作，同时只有一个线程成功， 造成大量线程自旋重试，降低并发性能。</p><h3 id="ThreadLocalRandom"><a href="#ThreadLocalRandom" class="headerlink" title="ThreadLocalRandom"></a>ThreadLocalRandom</h3><ul><li>ThreadLocalRandom中并没有存放具体的种子，具体的种子存放在具体的调用的线程的threadLocalRandomSeed变量里面。</li><li>ThreadLocalRandom类似ThreadLocal类，就是工具类</li><li>当线程调用ThreadLocalRandom的current方法时，ThreadLocalRandom负责初始化调用线程的threadLocalRandomSeed变量，也激素初始化种子。</li><li>当调用ThreadLocalRandom的netInt方法时，实际上是获取当前线程的ThreadLocalRandomSeed变量作为当前种子来计算新的种子，然后更新新的种子到当前线程的threadLocalRandomSeed变量，然后再根据新种子并使用具体算法计算随机数。</li><li>threadLocalRandomSeed变量就是Thread类中的一个普通的long类型变量，不是原子性变量。</li></ul><h2 id="Java并发包原子操作类"><a href="#Java并发包原子操作类" class="headerlink" title="Java并发包原子操作类"></a>Java并发包原子操作类</h2><h3 id="原子变量操作类"><a href="#原子变量操作类" class="headerlink" title="原子变量操作类"></a>原子变量操作类</h3><blockquote><p>AtomicInteger、AtomicLong、AtomicBoolean</p></blockquote><p>他们的内部都维护了一个value变量，是具体的值，还有valueOffset记录value变量的便宜量，内部通过unsafa类进行原子操作。</p><p>案例：多线程使用AtomicLong计算多个数组中0的个数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> chapter03;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicLong;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">AtomicLong</span> <span class="variable">count</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] arrOne = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">56</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] arrTwo = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">10</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">56</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">// threadOne 统计 arrOne中0的个数</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadOne</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arrOne.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arrOne[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                    count.getAndIncrement();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// threadTwo 统计 arrTwo中0的个数</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadTwo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arrTwo.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arrTwo[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                    count.getAndIncrement();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        threadTwo.start();</span><br><span class="line">        threadOne.start();</span><br><span class="line"></span><br><span class="line">        threadOne.join();</span><br><span class="line">        threadTwo.join();</span><br><span class="line">        System.out.println(<span class="string">&quot;count:&quot;</span> + count.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LongAdder"><a href="#LongAdder" class="headerlink" title="LongAdder"></a>LongAdder</h3><p>Atomic Long的缺陷：使用AtomicLong时，在高并发下大量线程会同时去竞争更新同一个原子变量，同时只有一个线程成功，其他线程自旋重试，白白浪费CPU资源。</p><p>LongAdder解决思路：把一个变量分解成多个变量，多个线程去竞争多个资源。</p><ul><li>LongAdder内部维护了多个Cell变量，每个cell变量里面有一个初始值为0的long类型的变量</li><li>多个cell变量，多个线程同时竞争一个变量的概率减小</li><li>当线程争夺Cell原子变量失败时，不会在当前Cell变量上一直自旋CAS重试，而是会在其他Cell变量上进行CAS尝试。</li><li>在获取LongAdder当前值时，是把所有Cell变量的value值累加后再加上base返回的。</li><li>Cell数组占内存较大，所以一开始并不创建（并发线程较少时不创建），惰性加载。</li><li>Cell数组的大小是2的N次方</li><li>Cell类型是AtomicLong类型的一个改进，用来减少缓存的争用，也就是解决伪共享问题（@sun.misc.Contented）</li><li>对于大多数孤立的多个原子操作进行字节填充是浪费的，因为i原子性操作都是无规律地分散在内存中，多个变量被放入同一个缓存行的可能性很小。但是由于原子性数组元素的内存地址是连续的，所以数组内的多个元素经常能共享缓存行，因此要使用注解@sun.misc.Contented对cell类进行字节填充。</li></ul><h3 id="LongAccumulator"><a href="#LongAccumulator" class="headerlink" title="LongAccumulator"></a>LongAccumulator</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">LongAccumulator</span> <span class="variable">count</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LongAccumulator</span>(<span class="keyword">new</span> <span class="title class_">LongBinaryOperator</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">applyAsLong</span><span class="params">(<span class="type">long</span> left, <span class="type">long</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> left + right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>applyAsLong 是你的计算公式，0是count的初始值，这个类比LongAdder更高级，提供了自定义的运算器以及初始值。 </p><h2 id="Java并发包中List源码分析"><a href="#Java并发包中List源码分析" class="headerlink" title="Java并发包中List源码分析"></a>Java并发包中List源码分析</h2><p>CopyOnWriteArrayList是并发包下的集合类，采用写时复制策略保证list的一致性。</p><p>CopyOnWriteArrayList增删改的过程都是用独占锁，来保证某个时间只有一个线程能对list数组进行修改。</p><p>写时复制策略一般会有弱一致性问题，所谓弱一致性是指返回迭代器后，其他线程对list的增删改查对迭代器是不可见的，迭代器遍历的数组就是一个快照。</p><p>案例：弱一致性演示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> chapter05;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CopyOnWriteArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CopyonWriteArrayListDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CopyOnWriteArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        list.add(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;456&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;789&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;012&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            list.set(<span class="number">0</span>, <span class="string">&quot;000&quot;</span>); <span class="comment">// 修改第一个值伪000</span></span><br><span class="line">            list.remove(<span class="number">1</span>); <span class="comment">// 移除第二个和第三个元素</span></span><br><span class="line">            list.remove(<span class="number">2</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 在子线程开启前获取迭代器，这样子线程的修改对迭代器就不可见</span></span><br><span class="line">        Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line">        thread.start();</span><br><span class="line">        thread.join();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">123</span></span><br><span class="line"><span class="number">456</span></span><br><span class="line"><span class="number">789</span></span><br><span class="line"><span class="number">012</span></span><br></pre></td></tr></table></figure><h2 id="Java并发包中锁原理分析"><a href="#Java并发包中锁原理分析" class="headerlink" title="Java并发包中锁原理分析"></a>Java并发包中锁原理分析</h2><h3 id="LockSupport工具类"><a href="#LockSupport工具类" class="headerlink" title="LockSupport工具类"></a>LockSupport工具类</h3><p>LockSupport类与每个使用它的线程都会关联一个许可证，在默认情况下调用LockSupport类的方法的线程不持有许可证，他的主要作用是挂起和唤醒线程，该工具类是创建锁和其他同步锁的基础。</p><blockquote><p>void park()方法</p></blockquote><p>如果调用park方法的线程已经拿到了与LockSupport关联的许可证，则调用该方法会马上返回，否则调用线程会被阻塞挂起。</p><blockquote><p>void unpark(Thread thread)方法</p></blockquote><ul><li>如果thread线程没有持有LockSupport的许可证，则让他持有。（之后再调用park就不会被阻塞了）</li><li>如果thread线程之前调用过park方法而阻塞，调用该方法后，唤醒thread线程</li></ul><blockquote><p>void park(Object blocker)</p></blockquote><p>当调用该方法被阻塞时（没有许可证），这个blocker会被记录到线程内部，使用诊断工具可以观察线程被阻塞的原因。 jstack命令</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ParkDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ParkDemo</span> <span class="variable">parkDemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ParkDemo</span>();</span><br><span class="line">        parkDemo.testPark();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPark</span><span class="params">()</span>&#123;</span><br><span class="line">        LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../img/contentImg/image-20220927173011703.png" alt="park信息"></p><blockquote><p>void parkNanos(Object blocker, long nanos) 与 void parkUtil(Object blocker, long deadline)</p></blockquote><p>nanos，如果线程已经得到许可证会立即返回，否则挂起nanos秒后返回。</p><p>util，如果线程已经得到许可证会立即返回，否则直到deadline时间后返回（从1970年开始计算的毫秒数）</p><h3 id="抽象同步队列AQS"><a href="#抽象同步队列AQS" class="headerlink" title="抽象同步队列AQS"></a>抽象同步队列AQS</h3><blockquote><p>AQS 锁的底层支持</p></blockquote><ul><li>AQS是一个FIFO的双向队列，队列的元素类型伪Node，Node中的thread变量用来存放进入AQS队列的线程</li><li>Node节点的SHARED用来标记该线程是获取共享资源时被阻塞挂起后放入AQS队列，EXCLUSIVE则是标记独占资源</li><li>AQS维持了一个单一的状态信息state（int 类型），对于不同的锁state可以用来表示不同的意思<ul><li>ReetrantLock可重入锁，state表示当前线程获取锁的可重入次数；</li><li>ReetrantReadWriteLock，state的高16位表示读状态，也就是获取该读锁的次数，低16位表示获取到写锁的线程的可重入次数；</li><li>对于CountDownlatch，state用来表示计数器当前的值；</li></ul></li><li>AQS有个内部类ConditionObject，用来结合锁实现线程同步，ConditionObject可以直接访问AQS对象内部的变量，比如state值和AQS队列。<ul><li>ConditionObject是条件变量，每个条件变量对应一个条件队列（与AQS队列不同），其用来存放调用条件变量的await方法后被阻塞的线程。</li><li>主要方法有await、signal、signalAll等</li></ul></li><li>AQS操作state变量的方法有<code>void acquire(int arg) void acquireInterruptibly(int art)【响应中断】 boolean release(int art)</code>，<code>void acquireShared(int arg) void acquireSharedInterruptibly(int art) boolean releaseShared(int arg)</code></li><li>AQS类并没有提供tryAcquire、tryRelease、acquireShared、releaseShared方法，需要由具体的子类来实现，子类在实现方法时，需要根据具体场景使用CAS算法尝试修改state状态值，成功返回true，失败返回false，子类还需要确定state状态值的含义</li></ul><blockquote><p>AQS条件变量</p></blockquote><ul><li>当多个线程同时调用lock.lock方法获取锁时，由于只有一个线程获取到了锁，其他线程会被转换成Node节点插入lock锁对应的AQS阻塞队列里面，并且自旋CAS尝试获取锁</li><li>如果获取到锁的线程又调用了对应的条件变量的await()方法，则该线程会释放获取到的锁，并抓换伪Node节点插入到条件变量对应的条件队列里面。</li><li>当另外一个线程调用条件变量的signal()或者是signalAll()方法时，会把条件队列里面的一个或者全部Node节点移动到AQS的阻塞队列里面，等待时机获取锁。</li></ul><p>总结：一个锁对应一个AQS阻塞队列，对应多个条件变量，一个条件变量都有自己的一个条件队列。</p><p><img src="/../img/contentImg/lock%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E9%98%9F%E5%88%97.png"></p><p>案例：基于AQS实现自定义同步器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> chapter06;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.AbstractQueuedSynchronizer;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NonReentrantLock</span> <span class="keyword">implements</span> <span class="title class_">Lock</span>, Serializable &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isHeldExclusively</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getState() == <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">            <span class="keyword">assert</span> acquires == <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))&#123;</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">            <span class="keyword">assert</span> releases == <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (getState() == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">            setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">            setState(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Condition <span class="title function_">newCondition</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConditionObject</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Sync</span> <span class="variable">sync</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sync</span>();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(time));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Condition <span class="title function_">newCondition</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sync.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="独占锁ReetrantLock原理"><a href="#独占锁ReetrantLock原理" class="headerlink" title="独占锁ReetrantLock原理"></a>独占锁ReetrantLock原理</h3><ul><li>ReetrantLock最终还是使用AQS来实现的</li><li>Sync直接继承AQS，它的子类NonfairSync和FairSync分别实现了获取锁的公平与非公平策略</li><li>这里AQS的state状态值表示线程获取该锁的可重入次数</li></ul><h3 id="ReetrantReadWriteLock的原理"><a href="#ReetrantReadWriteLock的原理" class="headerlink" title="ReetrantReadWriteLock的原理"></a>ReetrantReadWriteLock的原理</h3><p>适合写少读多的场景</p><ul><li>内部有一个ReadLock类和一个WriteLock类</li><li>AQS的高16位表示读状态，获取读锁的次数；低16位表示获取到写锁的线程的可重入次数</li></ul><h3 id="StampedLock锁"><a href="#StampedLock锁" class="headerlink" title="StampedLock锁"></a>StampedLock锁</h3><p>提供了三种模式的读写控制，当调用获取锁的系列函数时，会返回一个long型的变量</p><h2 id="Java并发包中并发队列"><a href="#Java并发包中并发队列" class="headerlink" title="Java并发包中并发队列"></a>Java并发包中并发队列</h2><h3 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h3><p>单向队列，有头指针和尾指针，非阻塞的CAS算法</p><ul><li>offer方法，向对尾添加元素（add方法也是，底层调用的offer方法）</li><li>poll方法，获取队头元素并移除</li><li>peek方法，获取队头元素不移除</li><li>size方法，获取当前队列元素个数，在并发环境下不是很有用，因为CAS没有加锁，所以从调用size函数到返回结果期间有可能增删元素，导致统计个元素个数不准确。</li><li>remove方法，如果队列里面存在该元素则删除该元素，如果存在多个则删除第一个，并返回true，否则返回false</li><li>contains方法，判断队列里面是否含有指定对象，由于是遍历整个队列，所以也像size一样结果可能不准确。</li></ul><h3 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h3><p>独占锁实现的阻塞队列</p><p>两个Node，分别表示头尾</p><p>初始值为0的原子变量count，表示队列元素的个数</p><p>两个ReetrantLock实例</p><ul><li>takeLock 用来控制同时只有一个线程可以从队头获取元素</li><li>putLock用来控制同时只有一个线程可以获取锁，在队尾添加元素</li></ul><p>offer方法，向队列尾部插入一个元素，如果队列中有空闲则插入成功后返回true，如果队列已满则丢弃当前元素然后返回false，该方法是非阻塞的。</p><p>put方法，向队列对尾插入一个元素，如果队列中有空闲则插入成功后直接返回，如果队列已满则阻塞当前线程，直到队列有空闲插入成功后返回。</p><p>poll方法，从队列头部获取并移除一个元素，如果队列为空则返回null，该方法不阻塞。</p><p>peek方法，获取队列头部元素但是不从队列移除，如果队列为空则返回null，方法不阻塞。</p><p>take方法，获取当前队列头部元素并从队列移除，如果当前队列为空，则阻塞当前线程，直到队列不为空，然后返回元素。</p><p>remove方法，删除队列里面的指定元素，有则删除并返回true，没有则返回false。</p><h3 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h3><p>使用有界数组方式实现的阻塞队列ArrayBlockingQueue</p><p>内部有一个items（Object类型）数组，用来存放队列元素，putindex变量表示入队元素下标，takeIndex变量是出队下标，count统计队列元素个数</p><p>独占锁lock用来保证出、入队操作的原子性，保证同一时刻只有一个线程可以进行入队、出队操作</p><p>notEmpty、notFull条件变量用来进行出、入队的同步。</p><p>offer方法，向队列尾部插入一个元素，如果队列有空闲空间则插入成功后返回true，如果队列已满则丢弃当前元素然后返回false，方法不阻塞</p><p>put方法，想队列队尾插入一个元素，如果队列已满则<strong>阻塞</strong>当前线程知道队列中有空闲并插入成功后返回true。</p><p>poll方法，从队列头部获取并移除一个元素，方法不阻塞</p><p>take方法，获取当前队列头部元素并从队列移除，如果当前队列为空，则阻塞当前线程，直到队列不为空，然后返回元素。</p><p>peek方法，获取队列头部元素但是不从队列移除，如果队列为空则返回null，方法不阻塞。</p><p>size方法，获取队列元素个数，准确的，因为计算前加了全局锁</p><h3 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h3><p>带优先级的无界阻塞队列，每次出队都返回优先级最高或者最低的元素。内部使用平衡二叉树堆实现的，所以直接遍历队列元素不保证有序。默认使用对象的compareTo方法提供比较规则，如果你需要自定义比较规则则可以自定义comparators。</p><blockquote><p>几个方法</p></blockquote><ol><li>public boolean offer(E e)<ul><li>在队列中插入一个元素，由于是无界队列，所以一直返回true</li></ul></li><li>public E poll()<ul><li>获取队列内部堆树的根节点，如果队列为空，返回null</li></ul></li><li>public void put()<ul><li>内部调用offer方法</li></ul></li><li>public E take()<ul><li>获取队列内部堆树的根节点，如果队列为空，则阻塞</li></ul></li></ol><h3 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h3><p>无界阻塞延迟队列，队列中每个元素都有个过期时间，当从队列获取元素时，只有过期元素才会出队列。队头元素是最快要过期的元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> chapter07;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.DelayQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Delayed;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DelayQueueDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建delay队列</span></span><br><span class="line">        DelayQueue&lt;DelayedEle&gt; delayedEles = <span class="keyword">new</span> <span class="title class_">DelayQueue</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 创建延迟任务</span></span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="type">DelayedEle</span> <span class="variable">ele</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DelayedEle</span>(random.nextInt(<span class="number">500</span>), <span class="string">&quot;task&quot;</span>+i);</span><br><span class="line">            delayedEles.offer(ele);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 依次取出任务并打印</span></span><br><span class="line">        <span class="type">DelayedEle</span> <span class="variable">ele</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;)&#123;</span><br><span class="line">                <span class="keyword">while</span> ((ele = delayedEles.take()) != <span class="literal">null</span>)&#123;</span><br><span class="line">                    System.out.println(ele.toString());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">DelayedEle</span> <span class="keyword">implements</span> <span class="title class_">Delayed</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> delayTime; <span class="comment">// 延迟时间</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> expire; <span class="comment">// 到期时间</span></span><br><span class="line">        <span class="keyword">private</span> String taskName; <span class="comment">// 任务名称</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">DelayedEle</span><span class="params">(<span class="type">long</span> delayTime, String taskName)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.delayTime = delayTime;</span><br><span class="line">            <span class="built_in">this</span>.taskName = taskName;</span><br><span class="line">            expire = System.currentTimeMillis() + delayTime;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 剩余时间 = 到期时间 - 当前时间</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> unit the time unit</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> 剩余时间</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getDelay</span><span class="params">(TimeUnit unit)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> unit.convert(<span class="built_in">this</span>.expire - System.currentTimeMillis(), TimeUnit.MILLISECONDS);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Delayed o)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="type">int</span>) (<span class="built_in">this</span>.getDelay(TimeUnit.MILLISECONDS) - o.getDelay(TimeUnit.MILLISECONDS));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;DelayedEle&#123;&quot;</span>);</span><br><span class="line">            sb.append(<span class="string">&quot;delay = &quot;</span>).append(delayTime);</span><br><span class="line">            sb.append(<span class="string">&quot;, expire = &quot;</span>).append(expire);</span><br><span class="line">            sb.append(<span class="string">&quot;, taskName = &quot;</span>).append(taskName).append(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            sb.append(<span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> sb.toString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程池ThreadPoolExecutor"><a href="#线程池ThreadPoolExecutor" class="headerlink" title="线程池ThreadPoolExecutor"></a>线程池ThreadPoolExecutor</h2><p>int corePoolSize：核心线程数</p><p>int maximumPoolSize：最大线程数</p><p>long keeyAliveTime：存活时间</p><p>TimeUnit unit：时间单位（对于上面的存活时间来说）</p><p>BlockingQueue<Runnable> workQueue：队列</p><p>threadFactory threadFactory：线程工厂</p><p>RejectedExecutionHandler handler：拒绝策略 </p><p>newCachedThreadPool：按需创建线程，核心线程为0，最多线程个数为Integer.MAX_VALUE，阻塞队列为同步队列，加入同步队列的任务会被马上执行，同步队列里面最多只有一个任务。（最快）可能会导致CPU100%</p><p>newFixedThreadPool()：核心线程个数和最大线程个数都为n，阻塞队列长度为Integer.MAX_VALUE。可能会导致内存溢出</p><p>newSingleThreadExecutor()：核心线程个数和最大线程个数都为1，可能会导致内存溢出</p><p>提交优先级：核心 &gt; 队列 &gt; 非核心</p><p>执行优先级：核心 &gt; 非核心 &gt; 队列</p><p>ThreadPoolExecutor实现实际是一个生产消费模型，当用户添加任务到线程池时，相当于生产者生产元素，workers线程工作集中的线程直接执行任务或者从任务i队列里面获取任务时，相当于消费着消费元素。</p><ul><li>public void execute(Runnable command)<ul><li>作用：提交任务command到线程池进行执行。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (command == <span class="literal">null</span>) <span class="comment">// （1）如果任务为null，则抛出NPE异常</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line"><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get(); <span class="comment">// （2）获取当前线程池的状态+线程个数变量的组合值</span></span><br><span class="line"><span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123; <span class="comment">// （3）</span></span><br><span class="line">    <span class="keyword">if</span> (addWorker(command, <span class="literal">true</span>))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    c = ctl.get();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123; <span class="comment">// （4）</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">recheck</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">    <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">        reject(command);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">        addWorker(<span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="literal">false</span>)) <span class="comment">// （5）</span></span><br><span class="line">    reject(command);</span><br></pre></td></tr></table></figure><p>代码3判断当前线程池中线程个数是否小于corePoolSize，如果是，则向workers里面新增一个核心线程执行该任务。</p><p>如果当前线程个数大于等于corePoolSize，则执行4，如果当前线程池状态处于RUNNING状态则添加任务到任务队列。</p><p>如果成功添加到任务队列中，则对线程池进行二次校验，这是因为添加任务到任务队列后，线程池的状态可能发生改变。</p><p>如果添加任务到任务队列失败，则说明任务队列已满，那么执行代码5尝试启动新线程（非核心）来执行该任务，如果当前线程池中线程个数大于max则执行拒绝策略。</p><ul><li>private boolean addWorker(Runnable firstTask, boolean core)</li></ul><blockquote><p>线程池复用原理</p></blockquote><p>线程池将线程和任务进行解耦，线程是线程，任务是任务，摆脱了之前通过 Thread 创建线程时的一个线程必须对应一个任务的限制。</p><p>在线程池中，同一个线程可以从阻塞队列中不断获取新任务来执行，其核心原理在于线程池对 Thread 进行了封装，并不是每次执行任务都会调用 Thread.start() 来创建新线程，而是让每个线程去执行一个“循环任务”，在这个“循环任务”中不停的检查是否有任务需要被执行，如果有则直接执行，也就是调用任务中的 run 方法，将 run 方法当成一个普通的方法执行，通过这种方式将只使用固定的线程就将所有任务的 run 方法串联起来。</p><blockquote><p>线程创建流程</p></blockquote><ul><li>当任务提交之后，线程池首先会检查当前线程数，如果当前的线程数小于核心线程数（corePoolSize），比如最开始创建的时候线程数为 0，则新建线程并执行任务。</li><li>当提交的任务不断增加，创建的线程数等于核心线程数（corePoolSize），新增的任务会被添加到 workQueue 任务队列中，等待核心线程执行完当前任务后，重新从 workQueue 中获取任务执行。</li><li>假设任务非常多，达到了 workQueue 的最大容量，但是当前线程数小于最大线程数（maximumPoolSize），线程池会在核心线程数（corePoolSize）的基础上继续创建线程来执行任务。</li><li>假设任务继续增加，线程池的线程数达到最大线程数（maximumPoolSize），如果任务继续增加，这个时候线程池就会采用拒绝策略来拒绝这些任务。</li></ul><blockquote><p>线程池状态</p></blockquote><ul><li>RUNNING：接受新任务并且处理阻塞队列里的任务</li><li>SHUTDIWB：拒绝新任务但是处理阻塞队列里的任务</li><li>STOP：拒绝新任务并且抛弃阻塞队列里面的任务，同时会中断正在处理的任务</li><li>TIDYING：所有任务都执行完（包含阻塞队列里面的任务）后当前线程池活动线程数为0，将要调用terminated方法。</li><li>TERMINATED：终止状态，terminated方法调用完成后的状态。</li></ul><h2 id="线程同步器原理"><a href="#线程同步器原理" class="headerlink" title="线程同步器原理"></a>线程同步器原理</h2><h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><p>场景：需要在主线程中开启多个线程去并行执行任务，并且主线程需要等待所有子线程执行完毕后再进行汇总。</p><p>CountDownLatch和join方法的区别：</p><ol><li>调用join方法后，线程会一直阻塞直到子线程执行完毕，而countDownLatch是根据计数器的值来决定阻塞方法是否返回，可以在子线程的任意位置通过countDown方法，让计数器减一，不用等到子线程结束。</li><li>一般都是通过线程池管理线程，传入的是Runnable，所以一般无法调用join方法</li></ol><p>CountDownLatch底层也是使用AQS实现的，AQS的state值就是CountDownLatch的计数器的值</p><blockquote><p>几个方法</p></blockquote><ol><li>void await()方法<ul><li>CountDownLatch对象调用await方法后，当前线程会被阻塞，直到所有线程都调用countDown方法，计数器的值为0，或者是其他线程调用了当先线程的interrupt方法中断线程，抛出异常。</li></ul></li><li>void countDown()方法<ul><li>计数器减一，CAS操作</li></ul></li><li>long getCount()方法<ul><li>获取计数器的当前值</li></ul></li></ol><h3 id="回环屏障CyclicBarrier"><a href="#回环屏障CyclicBarrier" class="headerlink" title="回环屏障CyclicBarrier"></a>回环屏障CyclicBarrier</h3><p>比CountDownLacth的功能更强大</p><p>所有线程都到达某一个屏障点后同时执行后续任务或者是同时继续屏障点后面的任务</p><p>可以复用且特别适合分段任务</p><blockquote><p>几个方法</p></blockquote><ol><li>int await()方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> chapter10;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CyclicBarrierDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">CyclicBarrier</span> <span class="variable">cyclicBarrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">2</span>, <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;两个任务合并后执行&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">        executorService.submit(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot; task1-1&quot;</span>);</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot; enter in barrier&quot;</span>);</span><br><span class="line">                System.out.println(cyclicBarrier.await());</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;enter out barrier&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        executorService.submit(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot; task1-2&quot;</span>);</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot; enter in barrier&quot;</span>);</span><br><span class="line">                System.out.println(cyclicBarrier.await());</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;enter out barrier&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> chapter10;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CyclicBarrierDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">CyclicBarrier</span> <span class="variable">CYCLIC_BARRIER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">        executorService.submit(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">&quot; step1&quot;</span>);</span><br><span class="line">                    CYCLIC_BARRIER.await();</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">&quot; step2&quot;</span>);</span><br><span class="line">                    CYCLIC_BARRIER.await();</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">&quot; step3&quot;</span>);</span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        executorService.submit(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">&quot; step1&quot;</span>);</span><br><span class="line">                    CYCLIC_BARRIER.await();</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">&quot; step2&quot;</span>);</span><br><span class="line">                    CYCLIC_BARRIER.await();</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">&quot; step3&quot;</span>);</span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Thread[pool-1-thread-1,5,main] step1</span><br><span class="line">Thread[pool-1-thread-2,5,main] step1</span><br><span class="line">Thread[pool-1-thread-1,5,main] step2</span><br><span class="line">Thread[pool-1-thread-2,5,main] step2</span><br><span class="line">Thread[pool-1-thread-2,5,main] step3</span><br><span class="line">Thread[pool-1-thread-1,5,main] step3</span><br></pre></td></tr></table></figure><h3 id="信号量Semaphore"><a href="#信号量Semaphore" class="headerlink" title="信号量Semaphore"></a>信号量Semaphore</h3><p>内部计数器是递增的，初始化时可以指定一个初始值</p><blockquote><p>几个方法</p></blockquote><ol><li>void acquire()方法</li></ol><ul><li>如果当前信号量个数大于0，则当前信号量的计数会减一，然后该方法直接返回，如果等于0，则放入AQS阻塞队列</li></ul><ol start="2"><li><p>void acquire(int permits)方法</p><ul><li>获取permits个信号量</li></ul></li><li><p>void release()方法</p><ul><li>把当前Semaphore对象的信号量加1</li></ul></li><li><p>void release(int permits)方法</p><ul><li>信号量增加permits个</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 高并发 </tag>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM</title>
      <link href="/2022/09/11/JVM/"/>
      <url>/2022/09/11/JVM/</url>
      
        <content type="html"><![CDATA[<h2 id="参考文献或视频资料"><a href="#参考文献或视频资料" class="headerlink" title="参考文献或视频资料"></a>参考文献或视频资料</h2><ol><li><a href="https://www.bilibili.com/video/BV1yE411Z7AP/?spm_id_from=333.337.search-card.all.click">黑马程序员JVM完整教程，Java虚拟机快速入门，全程干货不拖沓_哔哩哔哩_bilibili</a></li><li><a href="https://blog.csdn.net/sd_960614/article/details/126900380">(21条消息) JVM：（十六）垃圾回收器_叁弟的博客-CSDN博客</a></li><li>《深入理解Java虚拟机：第三版》</li></ol><h2 id="学习路线"><a href="#学习路线" class="headerlink" title="学习路线"></a>学习路线</h2><p><img src="/../img/contentImg/JVM%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="JVM结构图"></p><h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>定义：Program Counter Register  程序计数器 （寄存器）</p><p>指令不能交给CPU执行，通过解释器将二进制字节码解释成机器码，再交给CPU去执行</p><p>作用：程序计数器记住下一条JVM指令的执行地址</p><p>程序计数器在物理上是通过寄存器实现的，寄存器的读写速率非常快，而程序计数器读写地址非常频繁</p><p><img src="/../img/contentImg/image-20220911214547048.png" alt="程序计数器作用"></p><p>特点：</p><ol><li>线程私有：每个线程都有一份独立的程序计数器</li><li>JVM中唯一没有内存溢出结构</li></ol><h2 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>栈：线程运行需要的内存空间，每个线程运行时所需要的内存，称为虚拟机栈</p><p>栈帧：每个方法运行时需要的内存，比如方法参数、局部变量、返回地址等，方法结束后，栈帧从栈中出栈。</p><p>活动栈帧：每个线程只有一个活动栈帧，对应着当前正在执行的代码</p><p>一个栈中会存在多个栈帧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        method1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">        m2(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">m2</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a + b;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../img/contentImg/image-20220911221835920.png" alt="栈与栈帧"></p><p>问题辨析</p><ol><li>垃圾回收是否涉及栈内存？<ul><li>不涉及，因为栈帧在执行完成后，就自动出栈，不需要回收</li></ul></li><li>配置虚拟机栈内存大小<ul><li>-Xss1m  -Xss1024k</li></ul></li><li>虚拟机栈内存越大越好吗？<ul><li>不是，虚拟机栈内存变大，线程数对应变少。</li></ul></li><li>方法内的局部变量是否是线程安全的？<ul><li>如果方法内的局部变量没有逃离方法的作用范围，它是线程安全的，反之是线程不安全的（作为返回值、参数等）</li><li>如果局部变量引用了对象，并逃离了方法的作用范围，需要考虑线程安全问题</li></ul></li></ol><h3 id="栈内存溢出"><a href="#栈内存溢出" class="headerlink" title="栈内存溢出"></a>栈内存溢出</h3><p>StackOverflowError</p><ul><li>栈帧过多导致栈内存溢出（递归场景）</li></ul><p><img src="/../img/contentImg/image-20220911225559802.png" alt="StackOverflow"></p><ul><li><p>栈帧过大导致栈内存溢出</p><p>员工属性有姓名、部门，部门属性有员工、部门名称，无限套，可以使用@Jsonignore</p></li></ul><h3 id="线程运行诊断"><a href="#线程运行诊断" class="headerlink" title="线程运行诊断"></a>线程运行诊断</h3><ol><li>某个程序CPU占用率过高</li></ol><ul><li><p>用top定位哪个进程对cpu的占用率过高</p><p><img src="/../img/contentImg/image-20220911233227297.png" alt="top命令"></p><p>定位到进程32655</p></li><li><p>用ps H -eo pid,tid,%cpu | grep 进程id (用ps命令进一步定位哪个线程引起的cpu占用过高)</p><p>H：打印进程信息</p><p>-eo：打印需要信息 pid,tid,%cpu</p><p><img src="/../img/contentImg/image-20220911233430420.png" alt="ps命令"></p><p>定位到32665线程引起cpu占用过高</p></li><li><p>jstack 进程id，可以根据id找到有问题的线程，进一步定位到代码具体的位置</p><p>jstack 打印出来的线程id是16进制，32665对应16进制是0x7F99</p><p><img src="/../img/contentImg/image-20220911233807349.png" alt="jstack命令"></p></li></ul><ol start="2"><li>等了很久都没有输出东西（死锁）</li></ol><ul><li><p>jstack 进程id</p><p><img src="/../img/contentImg/image-20220911234155799.png" alt="jstack查看死锁"></p></li></ul><h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>为本地方法的运行提供内存空间。</p><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>Heap堆</p><ul><li>通过new关键字，创建对象都会使用堆内存</li></ul><p>特点</p><ul><li>他是线程共享的，堆中的对象都需要考虑线程安全的问题</li><li>有垃圾回收机制</li></ul><h3 id="堆内存溢出"><a href="#堆内存溢出" class="headerlink" title="堆内存溢出"></a>堆内存溢出</h3><p>OutOfMemoryError</p><p>-Xmx参数修改堆内存空间，在排查堆内存溢出错误时，最好将堆内存空间设置的小一点</p><h3 id="堆内存诊断"><a href="#堆内存诊断" class="headerlink" title="堆内存诊断"></a>堆内存诊断</h3><ol><li>jps工具<ul><li>查看当前系统中有那些Java进程</li></ul></li><li>jmap工具  jdk11以后使用jhsdb jmap –heap –pid<ul><li>查看堆内存占用情况，只能监测某一时刻</li></ul></li><li>jconsole工具<ul><li>图形界面的，多功能的检测工具，可以连续监测</li></ul></li></ol><p>案例</p><ul><li>垃圾回收后，内存占用率仍然很高</li></ul><p>jvisualvm -诊断工具</p><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><ol><li>所有Java虚拟机进程共享的区域（与堆类似）</li><li>存储跟类结构相关的信息，包括 属性、方法数据、成员方法、构造器</li><li>方法区在虚拟机启动时被创建</li><li>方法区逻辑上是堆的一个组成部分（概念上是堆的一部分，具体实现不确定）</li><li>方法区如果内存不足也会导致OutofMemory</li></ol><p><img src="/../img/contentImg/%E6%96%B9%E6%B3%95%E5%8C%BA%E7%BB%93%E6%9E%84.png" alt="JDK1.8方法区结构"></p><h3 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h3><p>元空间内存溢出：JDK1.8以后</p><p>修改元空间大小：-XX:MaxMetaspaceSize&#x3D;8m</p><h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><p>作用：给JVM指令提供常量符号，根据常量符号查找到对应常量。就是一张常量表，虚拟机指令根据这张常量表找到要执行的类名、方法名、方法参数、字面量等信息</p><h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>常量池是*.class文件中的，当该类被加载到虚拟机后，他的常量池信息就会放入运行时常量池，并把里面的符号地址变为真实地址。</p><h3 id="常量池与串池的关系"><a href="#常量池与串池的关系" class="headerlink" title="常量池与串池的关系"></a>常量池与串池的关系</h3><p>串池（StringTable ，hashtable结构，不能扩容）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用javap -v 反编译字节码文件</p><p><img src="/../img/contentImg/image-20220915224835724.png" alt="JVM指令"></p><p><img src="/../img/contentImg/image-20220915224958139.png" alt="运行时常量池"></p><p>常量池中的信息，都会被加载到运行时常量池中，这是a b ab都是常量池中的符号，还没有变为Java字符串对象。ldc #7 会把 a 符号变为 “a”字符串对象（先在StringTable中查找看有没有，如果没有则放入串池，如果存在就使用串池中的对象，一个值在串池中只存在一份），其他同理。</p><h3 id="字符串变量拼接"><a href="#字符串变量拼接" class="headerlink" title="字符串变量拼接"></a>字符串变量拼接</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>; <span class="comment">// 最终指向常量池中的数据</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s1 + s2; <span class="comment">// 最终指向堆中的对象</span></span><br><span class="line">    System.out.println(s3 == s4); <span class="comment">// false</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * StringBuilder temp = new StringBuild1er();</span></span><br><span class="line"><span class="comment">     * temp.append(&quot;a&quot;);</span></span><br><span class="line"><span class="comment">     * temp.append(&quot;b&quot;);</span></span><br><span class="line"><span class="comment">     * String s4 = temp.toString</span></span><br><span class="line"><span class="comment">     * toString：return new String()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字符串字面量拼接"><a href="#字符串字面量拼接" class="headerlink" title="字符串字面量拼接"></a>字符串字面量拼接</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s1 + s2;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span>; <span class="comment">// javac 在编译期间优化，结果已经在编译期确定为 ab</span></span><br><span class="line">    System.out.println(s3 == s5); <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../img/contentImg/image-20220916205612452.png" alt="字面量（常量）拼接"></p><p>字符串的延迟加载（懒加载）：常量字符串被引用时，它是缓加载的，遇到了才会被加载。</p><h3 id="StringTable-intern-1-8"><a href="#StringTable-intern-1-8" class="headerlink" title="StringTable_intern_1.8"></a>StringTable_intern_1.8</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s.intern(); <span class="comment">// intern 主动将串池中没有的字符串对象放入串池，如果有则不会放入</span></span><br><span class="line">    <span class="comment">// 此时s被放入串池中</span></span><br><span class="line">    System.out.println(s2 == <span class="string">&quot;ab&quot;</span>); <span class="comment">// true</span></span><br><span class="line">    System.out.println(s == <span class="string">&quot;ab&quot;</span>); <span class="comment">// true</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;ab&quot;</span>);</span><br><span class="line">    System.out.println(s3 == s2); <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>; <span class="comment">// 此时串池中已经有了&quot;ab&quot;对象</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;b&quot;</span>); <span class="comment">// 堆中的对象</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s1.intern(); <span class="comment">// 由于s串池中已经有了&quot;ab&quot;对象，所以不会把s1对象放入串池中，但是返回的仍然是串池中的对象，也就是s2仍然指向的是串池中的对象</span></span><br><span class="line">    System.out.println(s == s1); <span class="comment">// false </span></span><br><span class="line">    System.out.println(s == s2); <span class="comment">// true</span></span><br><span class="line">    <span class="comment">// 分析：s指向串池中的对象，s1指向堆中的对象，s2指向串池中的对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="StringTable位置"><a href="#StringTable位置" class="headerlink" title="StringTable位置"></a>StringTable位置</h3><p>JDK1.6之前，StringTable在常量池中，常量池又在方法区中，方法区的实现是永久代</p><p>JDK1.7，1.8之后，StringTable放入堆中了</p><h3 id="StringTable特性"><a href="#StringTable特性" class="headerlink" title="StringTable特性"></a>StringTable特性</h3><ul><li><p>常量池中的字符串仅时符号，第一次用到时才变为对象。</p></li><li><p>利用串池机制，可以避免重复创建字符串对象。</p></li><li><p>字符串变量拼接的原理是StringBuilder(1.8之后)</p></li><li><p>字符串常量的拼接原来是编译器的优化</p></li><li><p>可以使用intern方法，主动将串池中还没有的字符串<strong>对象</strong>放入串池。</p><ul><li>1.8 将这个字符串对象尝试放入串池，如果串池中已经存在，则不放入，如果没有则放入，会把池中的对象返回。</li><li>1.6 将这个字符串对象尝试放入串池，如果串池中已经存在，则不放入，如果没有，则把对象复制一份，放入串池，并把串池对象返回。也就是调用intern方法的对象，和最终放入串池的对象并不是同一个对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s1 + s2;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s6</span> <span class="operator">=</span> s4.intern();</span><br><span class="line"></span><br><span class="line">    System.out.println(s3 == s4); <span class="comment">// false s3：串池 s4：堆</span></span><br><span class="line">    System.out.println(s4 == s5); <span class="comment">// false s4：堆 s5：串池</span></span><br><span class="line">    System.out.println(s3 == s6); <span class="comment">// true 都是串池</span></span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">x2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;c&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;d&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">x1</span> <span class="operator">=</span> <span class="string">&quot;cd&quot;</span>;</span><br><span class="line">    x2.intern();</span><br><span class="line">    System.out.println(x1 == x2); <span class="comment">// false x2.intern 并不会将x2放入串池，因为已经存在&quot;cd&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>StringTable垃圾回收</p><p>几个虚拟机参数</p><p>-Xmx10m ：堆内存大小10m</p><p>-XX:+PrintStringTableStatistics：字符串表的统计信息，串池中字符串实例个数、大小等信息</p><p>-XX:+PrintGCDetails：打印GC详细信息</p></li></ul><p><img src="/../img/contentImg/image-20220916222610818.png" alt="StringTable"></p><p>按道理来说，每次添加一个不同的字符串，Number of entries和Number of literals 都会增加一个吗，但是当我们增加到一定程度后，发现数量并不是我们期待的，原因就是被回收了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">100000</span>; j++) &#123;</span><br><span class="line">            String.valueOf(i).intern();</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Throwable throwable)&#123;</span><br><span class="line">        throwable.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../img/contentImg/image-20220916223351044.png" alt="StringTable垃圾回收"></p><p>56177&lt;100000，其余的被回收掉了</p><h3 id="StringTable性能调优"><a href="#StringTable性能调优" class="headerlink" title="StringTable性能调优"></a>StringTable性能调优</h3><ul><li>-XX:StringTableSize&#x3D;10000 调节桶大小，如果要使用到比较多的字符串，建议适当增加桶个数，减少哈希冲突次数。</li><li>考虑字符串对象是否入池</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">    List&lt;String&gt; words = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">try</span>(<span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:\\WORK\\Java\\One\\src\\linux.words&quot;</span>))))&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">                line = br.readLine();</span><br><span class="line">                <span class="keyword">if</span> (line == <span class="literal">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                words.add(line); <span class="comment">// 只是将字符串加进list中，并没有入串池</span></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;cost:&quot;</span> + (System.nanoTime() - start) / <span class="number">1000000</span> );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.in.read(); <span class="comment">// 阻塞程序，防止程序终止</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>所有字母全部添加到List当中（10次）</p></blockquote><p><img src="/../img/contentImg/image-20220918143548639.png"></p><p>由图可以看到，循环10次，将所有字符串对象都放入List中，String和byte所占的内存之后大约在80%，这是因为List当中每个字符串都有10遍。</p><blockquote><p>所有字母全部添加到List当中（1次）</p></blockquote><p><code>words.add(line.intern())</code></p><p><img src="/../img/contentImg/image-20220918143942327.png"></p><p>String和byte内存总和仅占40%左右，被放入List中的对象是串池中的字符串对象，而堆中的字符串对象一开始仍然是有48万*10个，但是会被垃圾回收掉，（上面的程序因为被加入到List中，所以不会被垃圾回收）</p><h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><h3 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h3><p>直接内存使用的不是Java虚拟机内存，而是操作系统内存</p><p>特点：</p><ol><li>常见于NIO操作，用于数据缓冲区</li><li>分配回收成本较高，但读写性能较好</li><li>不受JVM内存回收管理</li></ol><ul><li>由于磁盘文件是无法直接写入Java虚拟机内存的，在文件复制时，需要将磁盘文件读入系统内存，然后系统内存再将内容写入Java虚拟机内存。中间经过两次复制过程。</li><li>直接内存就是在系统内存中画出一块区域用作缓冲区，这块内存Java代码可以直接访问，不需要再将内容写入到Java虚拟机后在访问，所以速度快很多。</li></ul><blockquote><p>直接内存进行文件复制</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">directBuffer</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">FileChannel</span> <span class="variable">from</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(FROM).getChannel();</span><br><span class="line">         <span class="type">FileChannel</span> <span class="variable">to</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(TO).getChannel();</span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">bb</span> <span class="operator">=</span> ByteBuffer.allocateDirect(_1Mb);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> from.read(bb);</span><br><span class="line">            <span class="keyword">if</span> (len == -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            bb.flip();</span><br><span class="line">            to.write(bb);</span><br><span class="line">            bb.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">    System.out.println(<span class="string">&quot;directBuffer 用时：&quot;</span> + (end - start) / <span class="number">1000_000.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接内存也会导致内存溢出</p><h3 id="直接内存释放原理"><a href="#直接内存释放原理" class="headerlink" title="直接内存释放原理"></a>直接内存释放原理</h3><p>直接内存并不会受到JVM内存回收机制影像，直接内存是通过Unsafe这个类的相关方法进行释放内存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">_1Gb</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> getUnsafe();</span><br><span class="line">    <span class="comment">// 分配内存</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">base</span> <span class="operator">=</span> unsafe.allocateMemory(_1Gb); <span class="comment">// base是内存地址</span></span><br><span class="line">    unsafe.setMemory(base, _1Gb, (<span class="type">byte</span>) <span class="number">0</span>);</span><br><span class="line">    System.in.read();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">    unsafe.freeMemory(base);</span><br><span class="line">    System.in.read();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过反射获取Unsafe对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Unsafe <span class="title function_">getUnsafe</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">f</span> <span class="operator">=</span> Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">        f.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> (Unsafe) f.get(<span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">return</span> unsafe;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchFieldException | IllegalAccessException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>ByteBuff回收原理</p></blockquote><ol><li>ByteBuffer.allocateDirect()方法会创建并返回一个DirectByteBuffer</li><li>DirectByteBuffer的构造函数中调用了Unsafe的相关方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">DirectByteBuffer(<span class="type">int</span> cap) &#123;                   <span class="comment">// package-private</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">super</span>(-<span class="number">1</span>, <span class="number">0</span>, cap, cap, <span class="literal">null</span>);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">pa</span> <span class="operator">=</span> VM.isDirectMemoryPageAligned();</span><br><span class="line">    <span class="type">int</span> <span class="variable">ps</span> <span class="operator">=</span> Bits.pageSize();</span><br><span class="line">    <span class="type">long</span> <span class="variable">size</span> <span class="operator">=</span> Math.max(<span class="number">1L</span>, (<span class="type">long</span>)cap + (pa ? ps : <span class="number">0</span>));</span><br><span class="line">    Bits.reserveMemory(size, cap);</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">base</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        base = UNSAFE.allocateMemory(size); <span class="comment">// 获取内存地址</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (OutOfMemoryError x) &#123;</span><br><span class="line">        Bits.unreserveMemory(size, cap);</span><br><span class="line">        <span class="keyword">throw</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    UNSAFE.setMemory(base, size, (<span class="type">byte</span>) <span class="number">0</span>); <span class="comment">// 设置内存大小</span></span><br><span class="line">    <span class="keyword">if</span> (pa &amp;&amp; (base % ps != <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">// Round up to page boundary</span></span><br><span class="line">        address = base + ps - (base &amp; (ps - <span class="number">1</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        address = base;</span><br><span class="line">    &#125;</span><br><span class="line">    cleaner = Cleaner.create(<span class="built_in">this</span>, <span class="keyword">new</span> <span class="title class_">Deallocator</span>(base, size, cap));</span><br><span class="line">    att = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>cleaner = Cleaner.create(this, new Deallocator(base, size, cap));</code> cleaner是一个虚引用，create方法将当前实例对象directbuffer（代码中的this）与cleaner进行绑定，当this被回收时，就会调用cleaner的clean方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clean</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!remove(<span class="built_in">this</span>))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        thunk.run();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Throwable x) &#123;</span><br><span class="line">        AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;&gt;() &#123;</span><br><span class="line">                <span class="keyword">public</span> Void <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (System.err != <span class="literal">null</span>)</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Cleaner terminated abnormally&quot;</span>, x)</span><br><span class="line">                            .printStackTrace();</span><br><span class="line">                    System.exit(<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                &#125;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的trunk是craete方法的第二个参数，是一个实现了Runnable接口的对象，trunk.run()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (address == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Paranoia</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    UNSAFE.freeMemory(address); </span><br><span class="line">    address = <span class="number">0</span>;</span><br><span class="line">    Bits.unreserveMemory(size, capacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在run方法中释放内存。</p><p>分析如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocateDirect(_1Gb);</span><br><span class="line">    System.out.println(<span class="string">&quot;分配完毕...&quot;</span>);</span><br><span class="line">    System.in.read();</span><br><span class="line">    System.out.println(<span class="string">&quot;开始释放...&quot;</span>);</span><br><span class="line">    byteBuffer = <span class="literal">null</span>;</span><br><span class="line">    System.gc(); <span class="comment">// 显式的垃圾回收，Full GC</span></span><br><span class="line">    System.in.read();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码中，最后直接内存也会被回收，因为byteBuffer指向null之后，该对象会被回收，与他绑定的cleaner对象就会调用clean方法，从而释放内存。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>直接内存回收原理：</p><ol><li>使用了Unsafe对象完成直接内存的分配回收，并且回收需要主动调用freeMemory方法</li><li>ByteBuffer的实现类内部，使用了Cleaner（虚引用）来监测ByteBuffer对象，一旦ByteBuffer对象被垃圾回收，那么就会由ReferenceHandler线程通过Cleaner的clean方法释放内存。</li></ol><p>-XX:+DisableExplicitGC  禁用显示内存回收，让System.gc()方法失效，这个同时也可能导致直接内存没有被回收</p><p>解决办法：通过Unsafe对象的freeMemory()方法直接释放内存。</p><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><h3 id="如何判断对象可以回收"><a href="#如何判断对象可以回收" class="headerlink" title="如何判断对象可以回收"></a>如何判断对象可以回收</h3><h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4><p>一个对象被引用了几次，就计数加几，当一个对象不再被引用时，计数为0，会被回收。但是这个方法存在循环引用的问题，</p><p><img src="/../img/contentImg/%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8.png" alt="循环引用"></p><p>此时A对象引用B对象，B对象引用A对象，造成循环依赖，两者一直相互引用，计数一直为1，内存无法得到释放，从而导致内存泄漏</p><h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><ul><li>Java虚拟机中的垃圾回收器采用可达性分析来探索所有存活的对象</li><li>扫描堆中的对象，看是否能够沿着<code>GC Root</code>对象为起点的引用找到该对象，找不到表示可以回收。</li><li>通过Eclipse提供的MAT工具查看哪些可以作为GC Root 对象</li></ul><h3 id="五种引用"><a href="#五种引用" class="headerlink" title="五种引用"></a>五种引用</h3><h4 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h4><ul><li>只有所有的GC Root对象都不通过[强引用]引用该对象，该对象才能被回收</li></ul><h4 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h4><ul><li>在垃圾回收后，如果内存仍然不足，通过软引用的对象就会被回收</li><li>可以通过配合引用队列来释放软引用自身<ul><li>当软引用对应的对象被回收后，该软引用就会被放入引用队列中，因为，软引用本身也占用一定内存，通过引用队列进行获取、回收等操作</li></ul></li></ul><p>应用场景：在项目中，比如查看图片的业务不是重要的业务，那么加载的那些图片，就可以设置成软引用或弱引用，当内存紧张时，释放部分图片的内存。</p><blockquote><p>强引用</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">_1Gb</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">_4Mb</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">4</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">    List&lt;<span class="type">byte</span>[]&gt; tu = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="type">byte</span>[] t = <span class="keyword">new</span> <span class="title class_">byte</span>[_4Mb];</span><br><span class="line">        tu.add(t);</span><br><span class="line">        System.out.println(i + <span class="string">&quot; ：&quot;</span>+ t.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/../img/contentImg/image-20220918211130641.png" alt="强引用结果"></p><p>可以看到，List中添加三个byte数组后，内存就已经不足，再往里面添加时，添加不进去，所以此时会进行垃圾回收，但是前面几个都是被<code>tu</code>进行强引用，不会被回收，所以此时内存溢出。</p><blockquote><p>软引用</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;SoftReference&lt;<span class="type">byte</span>[]&gt;&gt; tu = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    SoftReference&lt;<span class="type">byte</span>[]&gt; t = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">byte</span>[_4Mb]);</span><br><span class="line">    tu.add(t);</span><br><span class="line">    System.out.println(i + <span class="string">&quot; ：&quot;</span>+t.get());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (SoftReference&lt;<span class="type">byte</span>[]&gt; softReference : tu) &#123;</span><br><span class="line">    System.out.println(softReference.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../img/contentImg/image-20220918212143585.png" alt="弱引用"></p><p><img src="/../img/contentImg/image-20220920121215564.png"></p><p>可以看到List集合中前三个对象都被回收掉，所以为null</p><blockquote><p>引用队列</p></blockquote><p>通过引用队列，可以清除List集合中的空引用对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ReferenceQueue&lt;<span class="type">byte</span>[]&gt; queue = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;&gt;();</span><br><span class="line">List&lt;SoftReference&lt;<span class="type">byte</span>[]&gt;&gt; tu = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    SoftReference&lt;<span class="type">byte</span>[]&gt; t = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">byte</span>[_4Mb], queue);</span><br><span class="line">    tu.add(t);</span><br><span class="line">    System.out.println(i + <span class="string">&quot; ：&quot;</span>+t.get());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从队列中获取无用的软引用，并移除</span></span><br><span class="line">Reference&lt;? <span class="keyword">extends</span> <span class="title class_">byte</span>[]&gt; poll = queue.poll();</span><br><span class="line"><span class="keyword">while</span> (poll != <span class="literal">null</span>)&#123;</span><br><span class="line">    tu.remove(poll);</span><br><span class="line">    poll = queue.poll();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (SoftReference&lt;<span class="type">byte</span>[]&gt; softReference : tu) &#123;</span><br><span class="line">    System.out.println(softReference.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h4><p>WeakReference</p><ul><li>在垃圾回收后，不管内存是否充足，通过弱引用所引用的对象都会被回收。</li><li>可以通过配合引用队列来释放弱引用自身。</li></ul><h4 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h4><ul><li>必须配合引用队列使用，主要配合ByteBuffer使用，当引用对象被回收时，会将虚引用入队，由Reference Handler线程调用虚引用相关方法直接释放内存。</li></ul><h4 id="终结器引用"><a href="#终结器引用" class="headerlink" title="终结器引用"></a>终结器引用</h4><ul><li>重写了Object中的finalize()方法，并且没有强引用引用该对象时，在垃圾回收时，JVM会自动创建一个终结器引用，并将这个终结器引用放入引用队列中，然后由一个优先级较低的Finalize Handler线程到引用队列中找到该终结器引用，并调用该引用对象的finalze方法，该引用对象，在<strong>下一次</strong>垃圾回收时被回收</li></ul><h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><h4 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h4><p>标记清除算法，分为两个阶段</p><ul><li>标记：沿着GC Root引用链查找，如果发现一个引用对象，没有被GC Root直接或间接引用，则说明可以被回收，先将对象标记下来。</li><li>清除：把标记下来的对象进行清除，把对象所占用的内存的起始和结束地址记录到空闲地址列表中，下次再分配新对象时，到空闲地址列表中查找看有没有一块空间可以容纳新对象。</li></ul><p><img src="/../img/contentImg/image-20220920123046973.png"></p><p>优点：回收速度快，效率高</p><p>缺点：会产生空间碎片，很多小的碎片，如果这时候有一个需要大的内存的对象，那么这些小的不连续的空间都无法满足。</p><h4 id="标记整理"><a href="#标记整理" class="headerlink" title="标记整理"></a>标记整理</h4><p>标记阶段与标记清除算法一致</p><p>整理阶段：无用内存被回收后，后面的被使用的空间会向前移动</p><p><img src="/../img/contentImg/image-20220920123712002.png"></p><p>优点：没有内存碎片</p><p>缺点：速度较慢，需要移动对象地址，同时也要修改引用该对象的变量的值</p><h4 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h4><p>将内存划分成两块同样大小的区域（FROM和TO区域），其中FROM中用来存放对象，TO区域是不存放任何对象，空的。在进行垃圾回收时，标记出FROM区的对象，然后复制到TO区域，在复制过程中是紧挨着复制的，复制到TO区域后，内存是紧挨着连续的。最后交换FROM和TO区的位置即原来的FROM变为TO，原来的TO变为FROM</p><p><img src="/../img/contentImg/image-20220920124300514.png"></p><p>优点：不会产生内存碎片</p><p>缺点：占用双倍内存空间</p><h3 id="分代垃圾回收"><a href="#分代垃圾回收" class="headerlink" title="分代垃圾回收"></a>分代垃圾回收</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p><img src="/../img/contentImg/image-20220920142640441.png" alt="分代垃圾回收"></p><p>将Java虚拟机分成两块内存，新生代和老年代。其中新生代中又分成Eden（伊甸园区）和幸村区（幸存区From和幸存区To）。</p><ul><li>创建对象时首先分配到伊甸园区</li><li>当伊甸园区内存不足时，会触发一次Minor GC，采用的方式是复制垃圾回收算法。将伊甸园中个From区中保留下来的对象（如果From中也有幸存对象）放入幸存区To中，再交换From和To的位置。并且幸存区的对象的寿命加一。</li><li>当对象寿命超过阈值时（最大15次），会将对象放入老年代中。</li><li>当老年代空间和新生代空间都不足时，此时会先尝试Minor GC，如果之后空间仍不足，那么会触发Full GC</li><li>Minor GC 和 Full GC 都会引发stop the world ，暂停其他用户线程，等待垃圾回收完成，恢复运行。</li></ul><h4 id="相关VM参数"><a href="#相关VM参数" class="headerlink" title="相关VM参数"></a>相关VM参数</h4><p><img src="/../img/contentImg/image-20220920150128859.png"></p><p>大对象直接入老年代：当一个对象所需的内存超过设置的大小时，这个对象会直接放入老年代中。我们知道新生代的<a href="https://so.csdn.net/so/search?q=%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6&spm=1001.2101.3001.7020">垃圾回收</a>算法采用了复制算法，<strong>复制算法有一个缺点就是当存在大量大对象的时候会导致每次回收效率下降，因为要复制移动对象\。</strong></p><blockquote><p>注意点</p></blockquote><p>如果是在子线程中发生了OOM，并不会影响主线程继续运行，但是子线程所占用的内存空间并不会被释放</p><h3 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h3><blockquote><p>评估GC性能的指标</p></blockquote><ul><li>吞吐量：CPU运行用户代码的时间占CPU总运行时间的比例（比如虚拟机总共运行了100分钟，1分钟用于垃圾回收，那吞吐量就是99%）</li><li>暂停时间（响应时间）：执行垃圾回收时，程序的工作线程被暂停的时间</li><li>内存占用：Java堆内存所占的内存大小</li></ul><h4 id="串行"><a href="#串行" class="headerlink" title="串行"></a>串行</h4><ul><li>单线程</li><li>适合堆内存较小的场景（个人电脑）CPU个数较少</li><li>-XX:+UseSerialGC &#x3D; Serial &#x2F; SerialOld</li></ul><p>Serial：新生代，复制算法</p><p>Serial Old：老年代，标记整理，该收集器同时作为CMS收集器失败后的预备方案</p><p><img src="/../img/contentImg/image-20220920162126168.png" alt="串行回收器示意图"></p><p>流程：当程序运行时，发生垃圾回收，其他用户线程到达安全点后阻塞，等待垃圾回收线程完成垃圾回收后，继续运行。</p><h4 id="吞吐量优先"><a href="#吞吐量优先" class="headerlink" title="吞吐量优先"></a>吞吐量优先</h4><ul><li>多线程</li><li>适合内存较大，适合多核CPU</li><li>让单位时间内，STW的时间最短  比如一小时内STW时间最少 0.2 + 0.2 &#x3D; 0.4</li><li>-XX:+UseParallelGC ~ -XX:+UseParallelOldGC 开启吞吐量有限回收器（JDK8 默认）</li><li>-XX:+UseAdaptiveSizePolicy  自适应调整新生代内存大小</li><li>-XX:GCTimeRatio&#x3D;ratio 设置单位时间内，垃圾回收时间的比例  1 &#x2F; (1 + radio)<ul><li>radio默认是99，即在100个单位时间内，最多允许1个单位时间（并不一定是连续时间）进行垃圾回收</li><li>一般设置这个参数时，会让内存变大，内存变大回收次数少，时间也短。一般设置成19</li><li>在这种模式下，年轻代的大小、Eden和Survivor的比例、晋升老年代的对象年龄等参数会被自动调整，已达到在堆大小、吞吐量和停顿时间之间的平衡点。</li><li>在手动调优比较困难的场合，可以直接使用这种自适应的方式，仅指定虚拟机的最大堆、目标的吞吐量（GCTimeRatio）和停顿时间（MaxGCPauseMills），让虚拟机自己完成调优工作。</li></ul></li><li>-XX:MaxGCPauseMillis&#x3D;ms 设置单次垃圾回收的最大时间限制（STW时间）<ul><li>默认值是200ms</li><li>这个值会让内存变小，比如设置成1，只有内存很小时，1ms才能完成垃圾回收</li><li>实际应用时要和上面的参数取一个折中的值。</li></ul></li><li>-XX:ParallelGCThreads&#x3D;n 设置老年代并行收集器线程数。</li></ul><p><strong>高吞吐量可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务</strong>。因此，常见在服务器环境中使用。例如，那些执行批量处理、订单处理、工资支付、科学计算的应用程序。</p><p><img src="/../img/contentImg/image-20220920163931751.png" alt="吞吐量优先回收期"></p><h4 id="响应时间优先"><a href="#响应时间优先" class="headerlink" title="响应时间优先"></a>响应时间优先</h4><ul><li>多线程</li><li>适合内存较大，适合多核CPU</li><li>尽可能让STW单次的时间最短  0.1 + 0.1 + 0.1 + 0.1 + 0.1 &#x3D; 0.5</li><li>适用于与用户交互频繁的场景</li></ul><p>CMS垃圾回收器</p><p><strong>这款收集器是HotSpot虚拟机中第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程同时工作。</strong></p><p><strong>CMS的垃圾收集算法采用标记-清除算法，并且也会”Stop-the-World”</strong></p><blockquote><p>回收过程</p></blockquote><p>CMS整个过程比较复杂，整个过程分为4个主要阶段，即初始标记阶段、并发标记阶段、重新标记阶段和并发清除阶段:</p><ul><li>初始标记（Initial-Mark）阶段：在这个阶段会出现“Stop-the-World”机制，这个阶段的主要任务仅仅只是标记出GCRoots能直接关联到的对象。由于直接关联对象比较小，所以这里的速度非常快。</li><li>并发标记（Concurrent-Mark）阶段：从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行。</li><li>重新标记（Remark）阶段：此阶段会出现STW，主要用于修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短。</li><li>并发清除（Concurrent-Sweep）阶段：此阶段清理删除掉标记阶段判断的已经死亡的对象，释放内存空间。由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的</li></ul><blockquote><p>分析</p></blockquote><p>尽管CMS收集器采用的是并发回收（非独占式），但是在其初始化标记和再次标记这两个阶段中仍然需要执行“Stop-the-World”机制暂停程序中的工作线程。由于最耗费时间的并发标记与并发清除阶段都不需要暂停工作，所以整体的回收是低停顿的。</p><p>另外，由于在垃圾收集阶段用户线程没有中断，所以在CMS回收过程中，还应该确保应用程序用户线程有足够的内存可用。因此，CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，而是当堆内存使用率达到某一阈值时，便开始进行回收。要是CMS运行期间预留的内存无法满足程序需要，就会出现Concurrent Mode Failure 失败，这时虚拟机将启动后备预案：临时启用Serial Old来重新进行老年代的垃圾收集，这样停顿时间就很长了。</p><blockquote><p>优点</p></blockquote><ul><li>并发收集、非独占式</li><li>低延时，低停顿、用户体验好</li></ul><blockquote><p>缺点</p></blockquote><ul><li>使用标记清除算法，会产生内存碎片</li><li>无法处理浮动垃圾（浮动垃圾就是垃圾并发阶段产生的新垃圾，CMS无法对这种垃圾进行标记与回收）</li><li>可能会产生Concurrent Mode Failure，导致产生Full GC</li><li>对CPU资源敏感，因为i垃圾回收要抢占CPU资源，可能导致用户线程变慢，从而降低吞吐量。</li></ul><blockquote><p>相关参数</p></blockquote><ol><li><code>-XX:+UseConcMarkSweepGC</code>手动指定使用CMS收集器执行内存回收任务。开启该参数后会自动将<code>-xx:+UseParNewGC</code>打开</li><li><code>-XX:CMSInitiatingOccupanyFraction</code> 设置堆内存使用率的阈值，一旦达到该阈值，便开始进行回收。</li><li><code>-XX:+UseCMSCompactAtFullCollection</code> 用于指定在执行完Full GC后对内存空间进行压缩整理，以此避免内存碎片的产生。不过由于内存压缩整理过程无法并发执行，所带来的问题就是停顿时间变得更长了。</li><li><code>-XX:CMSFullGCsBeforeCompaction</code> 设置在执行多少次Full GC后对内存空间进行压缩整理。</li><li><code>-XX:ParallelcMSThreads</code> 设置CMS的线程数量。</li></ol><p>不幸的是”高吞吐量”和”低暂停时间”是一对相互竞争的目标（矛盾），垃圾回收总时间&#x3D;垃圾回收线程工作时间+切换线程时间+其他。因为如果选择以吞吐量优先，那么必然需要降低内存回收的执行频率，但是这样会导致GC需要更长的暂停时间来执行内存回收。如果选择以低延迟优先为原则，那么为了降低每次执行内存回收时的暂停时间，回收的次数必然会增加，与此同时，线程之间切换的开销也会增加，这无疑增加了垃圾回收的时间成本，造成吞吐量的下降</p><p>现在标准：<strong>在最大吞吐量优先的情况下，降低停顿时间</strong></p><blockquote><p>垃圾回收器的选择</p></blockquote><ul><li><strong>如果你想要最小化地使用内存和并行开销，请选Serial GC；</strong></li><li><strong>如果你想要最大化应用程序的吞吐量，请选Parallel GC；</strong></li><li><strong>如果你想要最小化GC的中断或停顿时间，请选CMS GC。</strong></li></ul><h4 id="垃圾回收器与垃圾分代的关系"><a href="#垃圾回收器与垃圾分代的关系" class="headerlink" title="垃圾回收器与垃圾分代的关系"></a>垃圾回收器与垃圾分代的关系</h4><p><img src="/../img/contentImg/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%88%86%E4%BB%A3%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="垃圾回收器与垃圾分代的关系"></p><ul><li>新生代收集器：Serial GC、ParNew GC、Parallel Scavenge GC</li><li>老年代收集器：Serial Old GC、CMS GC、Parallel Old GC</li><li>整堆收集器：G1</li></ul><h4 id="垃圾回收器的组合关系"><a href="#垃圾回收器的组合关系" class="headerlink" title="垃圾回收器的组合关系"></a>垃圾回收器的组合关系</h4><p><img src="/../img/contentImg/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E7%9A%84%E7%BB%84%E5%90%88%E5%85%B3%E7%B3%BB.png" alt="垃圾回收器的组合关系"></p><h4 id="Garbage-First"><a href="#Garbage-First" class="headerlink" title="Garbage First"></a>Garbage First</h4><blockquote><p>适用场景</p></blockquote><ul><li>同时注重吞吐量（Throughput）和低延迟（Low latency），默认暂停目标是200ms</li><li>超大内存堆，会将堆划分成多个大小相等的region</li><li>整体上是标记整理算法，两个区域之间是复制算法</li></ul><blockquote><p>概述</p></blockquote><p>G1是一个并行回收器，它把堆内存分割成很多不相关的区域（Regin，物理上不连续），每一块Region都可以用来表示Eden、幸存区（幸存区From，幸存区To）、老年代等。G1 GC避免在整个Java堆中进行全区域的垃圾回收，取而代之的是跟踪各个Region里面的垃圾堆积的价值大小，每次根据允许的收集时间，优先回收价值最大的Region。<strong>由于这种方式的侧重点在于回收垃圾价值最大的区域Region</strong>，故而称<strong>垃圾优先（Garbage First）</strong>。G1是JDK9以后的默认的垃圾回收器。</p><blockquote><p>优点</p></blockquote><ul><li>并行性：G1在回收期间，可以有多个GC线程同时工作，有效利用多核计算能力，此时用户线程STW。</li><li>并发性：G1拥有与应用程序交互执行的能力，部分工作可以和应用程序同时执行，因此，一般来说，不会出现在整个回收阶段完全阻塞应用程序的情况。</li><li>分代收集：能同时回收年轻代和老年代。</li><li>空间整合：G1内存回收是以Region为单位，Region之间是复制算法，但整体上实际可以看作是标记-整理算法，两种算法都可以避免内存碎片。</li><li>可预测的停顿时间模型（即软实时，soft real-time）：每次根据允许的收集时间，优先回收价值最大的Region</li></ul><blockquote><p>相关参数</p></blockquote><ul><li><code>-XX:+UseG1GC</code>：手动指定使用G1垃圾收集器执行内存回收任务</li><li><code>-XX:G1HeapRegionSize</code> 设置每个Region的大小。值是2的幂，范围是1MB到32MB之间，目标是根据最小的Java堆大小划分出约2048个区域。默认是堆内存的1&#x2F;2000。</li><li><code>-XX:MaxGCPauseMillis</code> 设置期望达到的最大GC停顿时间指标（JVM会尽力实现，但不保证达到）。默认值是200ms（人的平均反应速度）</li><li><code>-XX:+ParallelGCThread</code> 设置STW工作线程数的值。最多设置为8</li><li><code>-XX:ConcGCThreads</code> 设置并发标记的线程数。将n设置为并行垃圾回收线程数（ParallelGCThreads）的1&#x2F;4左右。</li><li><code>-XX:InitiatingHeapOccupancyPercent</code> 设置触发并发GC周期的Java堆占用率阈值。超过此值，就触发GC。默认值是45。</li></ul><blockquote><p>G1回收器的常见操作步骤</p></blockquote><p>G1的设计原则就是简化JVM性能调优，开发人员只需要简单三步即可完成：</p><ol><li>开启G1垃圾回收器</li><li>设置堆的最大内存</li><li>设置最大停顿时间</li></ol><blockquote><p>分区Region</p></blockquote><p>使用G1收集器时，它将整个Java堆分成约2048个大小相同的独立Region块，每个Region块大小在1MB到32MB之间，且为<strong>2的N次幂</strong>，即1M，2M，4M，8M，16M，32M。可以通过 <code>-XX:G1HeapRegionSize</code>设定，所有的Region大小相同，且在JVM生命周期内不会被改变。</p><p>虽然还保留新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region（不需要连续）的集合。通过Region的动态分配方式实现逻辑上的连续。</p><p>一个Region在使用过程中不可发生角色变换，但在垃圾回收清除后，会变成空白Region，此时若再使用这一块Region，可以发生角色变换。</p><p>G1垃圾回收器还增加了一种新的内存区域，叫做Humongous内存区域，主要用于存储大对象，如果对象所需内存超过1.5个Region大小，就放到Humnogous区域</p><p><img src="/../img/contentImg/G1%E5%88%92%E5%88%86%E7%9A%84Region%E5%8C%BA%E5%9F%9F.png" alt="G1划分的Region区域"></p><blockquote><p>G1垃圾回收器的回收过程</p></blockquote><p>分成如下三个环节：</p><ul><li>年轻代GC（Young GC）</li><li>老年代并发标记过程（Concurrent Marking）</li><li>混合回收（Mixed GC）</li></ul><p>![G1 垃圾回收器的回收过程](..&#x2F;img&#x2F;contentImg&#x2F;G1 垃圾回收器的回收过程.png)</p><p>当年轻代的Eden区用尽时开始年轻代回收过程。G1的年轻代收集阶段是一个并行的独占式收集器。</p><p>当堆内存使用达到一定值（默认45%）时，开始老年代并发标记过程。标记完成马上开始混合回收过程。对于一个混合回收期，G1的老年代回收器不需要整个老年代被回收，一次只需要扫描&#x2F;回收一小部分老年代的Region。老年代Region是和年轻代一起被回收的。</p><p>举个例子：一个Web服务器，Java进程最大堆内存为4G，每分钟响应1500个请求，每45秒钟会新分配大约2G的内存。G1会每45秒钟进行一次年轻代回收，每31个小时整个堆的使用率会达到45%，会开始老年代并发标记过程，标记完成后开始四到五次的混合回收。</p><blockquote><p>Remembered Set</p></blockquote><p>所有回收器存在的问题（G1）</p><ul><li>一个对象被不同区域引用的问题</li><li>一个Region不可能是独立的，一个Region中的对象可能被其他任意Region中对象引用，判断对象存活时，是否需要扫描整个Java堆才能保证准确？</li><li>在其他分代回收器，也存在这样的问题（G1更突出）回收新生代也不得不同时扫描老年代？</li><li>这样的话会降低Minor GC的效率</li></ul><p>解决办法：</p><p>无论是G1收集器还是其他分代收集器，JVM都是通过使用Remembered Set 和 CardTable来避免全局扫描的。</p><p>将老年代进一步划分，分成一个个card，每一块大小为512Byte，如果某个card引用了其他Region区域的对象，就将该card标记为脏卡，并在被引用的对象所在的Region区域的Remembered Set中。当进行垃圾收集时，在GC根节点的枚举范围加入RememberedSet，就可以保证不进行全局扫描，也不会有遗漏。</p><h5 id="年轻代GC"><a href="#年轻代GC" class="headerlink" title="年轻代GC"></a>年轻代GC</h5><p>当Eden空间耗尽时，G1会启动一次年轻代垃圾回收过程。年轻代垃圾回收只会回收Eden区和Survivor区</p><p><img src="/../img/contentImg/G1%E5%B9%B4%E8%BD%BB%E4%BB%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.png" alt="G1年轻代垃圾回收"></p><blockquote><p>回收过程</p></blockquote><ul><li>第一阶段，扫描根。根是指static变量指向的对象，正在执行的方法调用链条上的局部变量等。根引用连同RSet记录的外部引用作为扫描存活对象的入口。</li><li>第二阶段，更新RSet。处理dirty card queue中的card，更新RSet。此阶段完成后，RSet可以准确的反映老年代对所在的内存分段中对象的引用。RSet是公共资源，使用脏卡表dirty card queue是为了避免线程同步带来的问题。</li><li>第三阶段，处理RSet。识别被老年代对象指向的Eden中的对象，这些被指向的Eden中的对象被认为是存活的对象。</li><li>第四阶段，复制对象。Eden区内存段中存活的对象会被复制到Survivor区中空的内存分段，根据年龄阈值或对象大小决定是否晋升老年代。</li><li>第五阶段，处理引用。处理Soft，Weak，Phantom等引用。最终Eden空间的数据为空，GC停止工作，而目标内存中的对象都是连续存储的，没有碎片，所以复制过程可以达到内存整理的效果，减少碎片。</li></ul><h5 id="并发标记"><a href="#并发标记" class="headerlink" title="并发标记"></a>并发标记</h5><ul><li>初始标记阶段：标记从根节点直接可达的对象。这个阶段是STW的，并且会触发一次年轻代GC。</li><li>根区域扫描（Root Region Scanning）：G1 GC扫描Survivor区直接可达的老年代区域对象，并标记被引用的对象。</li><li>并发标记（Concurrent Marking）：在整个堆中进行并发标记（和应用程序并发执行），此过程可能被YoungGC中断。在并发标记阶段，若发现区域对象中的所有对象都是垃圾，那这个区域会被立即回收。同时，并发标记过程中，会计算每个区域的对象活性。</li><li>再次标记（Remark）：由于应用程序持续进行，需要修正上一次的标记结果。是STW的。G1中采用了比CMS更快的初始快照算法：snapshot-at-the-beginning（SATB）。</li><li>独占清理（cleanup，STW）：计算各个区域的存活对象和GC回收比例，并进行排序，识别可以混合回收的区域。为下阶段做铺垫。是STW的。这个阶段并不会实际上去做垃圾的收集</li><li>并发清理阶段：识别并清理完全空闲的区域。</li></ul><h5 id="混合回收"><a href="#混合回收" class="headerlink" title="混合回收"></a>混合回收</h5><p>当越来越多的对象晋升到老年代Old region时，为了避免堆内存被耗尽，会触发一个混合的垃圾收集器，即Mixed GC，该算法并不是一个Old GC，除了回收整个Young Region，还会回收一部分的Old Region。这里需要注意：是一部分老年代，而不是全部老年代。可以选择哪些Old Region进行收集，从而可以对垃圾回收的耗时时间进行控制。也要注意的是Mixed GC并不是Full GC。<br><img src="/../img/contentImg/G1%E6%B7%B7%E5%90%88%E5%9B%9E%E6%94%B6.png" alt="G1混合回收"></p><p>并发标记结束以后，老年代中百分百为垃圾的内存分段被回收了，部分为垃圾的内存分段被计算了出来。默认情况下，这些老年代的内存分段会分8次（可以通过-XX:G1MixedGCCountTarget设置）被回收，但也不是绝对的，当内存占用低于某个阈值，则不会再执行Mixed GC。Mixed GC的算法和年轻代GC的算法完全一样。</p><h5 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h5><p>G1的初衷就是要避免Full GC的出现。但是如果上述方式不能正常工作，G1会停止应用程序的执行（Stop-The-World），使用单线程的内存回收算法进行垃圾回收，性能会非常差，应用程序停顿时间会很长。</p><p>要避免Full GC的发生，一旦发生需要进行调整。什么时候会发生Full GC呢？比如堆内存太小，当G1在复制存活对象的时候没有空的内存分段可用，则会回退到Full GC，这种情况可以通过增大内存解决。</p><p>导致G1 Full GC的原因可能有两个：</p><ul><li>复制对象的时候没有足够的to-space来存放晋升的对象；</li><li>并发过程中空间耗尽，用户线程无法分配内存。</li></ul><h3 id="垃圾回收调优"><a href="#垃圾回收调优" class="headerlink" title="垃圾回收调优"></a>垃圾回收调优</h3><h2 id="虚拟机类加载机制"><a href="#虚拟机类加载机制" class="headerlink" title="虚拟机类加载机制"></a>虚拟机类加载机制</h2><p>Java 虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验、转换解 析和初始化，最终形成可以被虚拟机直接使用的 Java 类型，这个过程被称作虚拟机的类加载机制</p><h3 id="类的加载时机"><a href="#类的加载时机" class="headerlink" title="类的加载时机"></a>类的加载时机</h3><blockquote><p>类的生命周期</p></blockquote><p><img src="/../img/contentImg/%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="类的生命周期"></p><p>加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的，而解析阶段则不一定；它在某些情况下可以在初始化阶段之后再开始。这是为了支持Java语言的动态绑定机制。</p><blockquote><p>必须进行初始化的几种情况</p></blockquote><p>需要说明的是：初始化之前一定发生了加载、验证、准备</p><ol><li>遇到new、getstatic、putstatic或invokestatic这四条字节码指令时，如果类型没有进行过初始化，则需要先触发初始化阶段。能够触发这四条指令的场景有如下几个。<ol><li>使用new关键字实例化对象的时候。</li><li>读取或设置一个类型的静态字段的时候（被final修饰、已在编译期把结果放入常量池的静态字段除外）</li><li>调用一个类型的静态方法的时候。</li></ol></li><li>试用java.lang.reflect包的方法对类型进行反射调用的时候，如果类型没有进行过初始化，则需要先触发初始化阶段。</li><li>当初始化类时发现其父类还没有进行初始化，需要先触发其父类的初始化。</li><li>当虚拟机启动时，用户需要指定一个要执行的主类（包含main方法的那个类），虚拟机会先去初始化这个类。</li><li>当一个接口中定义了JDK8新加入的默认方法时（被default关键字修饰的接口方法），如果有实现这个接口的类要被初始化，那么该接口要在其之前被初始化。</li><li>当使用 JDK 7 新加入的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果为 REF_getStatic、 REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial 四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。</li></ol><p>注意：有且只有这六种情况才会触发类的初始化，这种方式叫做主动引用。除此之外，所有引用类型的方式都不会触发类的初始化，称为被动引用。</p><blockquote><p>被动引用的几个例子</p></blockquote><ol><li>通过子类引用父类的静态字段，不会导致子类初始化。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> chapter07;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PassiveReference</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(Father.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;father initialization&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;son initialization&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">father initialization</span><br><span class="line">1000</span><br></pre></td></tr></table></figure><p>没有触发子类的初始化，至于是否要触发子类的加载和验证阶段，取决与虚拟机的具体实现。对于Hotspot虚拟机，会触发加载阶段。</p><ol start="2"><li>通过数组定义来引用类，不会触发类的初始化。</li></ol><p><code>Father[] fathers = new Father[10];</code>这行代码不会触发上述Father类的初始化</p><ol start="3"><li>常量在编译阶段会存入<strong>调用类</strong>的常量池，本质上没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PassiveReference</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(Father.hello);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;father initialization&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">hello</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br></pre></td></tr></table></figure><p>原因：在编译阶段通过常量传播优化，已经将此常量值”hello”直接存储在PassiveReference类的常量池中，以后PassiveReference对常量Father.hello的引用实际都被转化为对自身常量池的引用。</p><p>注意：接口的加载过程与类加载过程稍有不同（上述有且仅有的六种触发初始化场景中的第三种）。当一个类初始化时，要求其父类全部都已经初始化过了，但是一个接口在初始化时，并不要求其父接口全部都初始化完成，只有真正使用到父接口的时候才会初始化（如引用接口中定义的变量）。</p><h3 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h3><h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><p>在加载阶段，Java虚拟机需要完成以下三件事情。</p><ol><li>通过一个类的全限定名来获取定义此类的二进制字节流。</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li><li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</li></ol><p>加载阶段结束后，Java虚拟机外部的二进制字节流就按照虚拟机所设定的格式存储在方法区中了，方法区中的数据存储格式完全由虚拟机实现自行定义。类型数据妥善安置在方法区之后，会在Java堆内存中实例化一个java.lang.Class类的对象，这个对象作为程序访问方法区中的类型数据的外部接口。</p><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>验证阶段是连接阶段的第一步，这一阶段的目的是确保Class文件的字节流包含的信息符合《Java虚拟机规范》的全部约束要求，确保这些信息被当作代码运行后不会危害虚拟机自身安全。</p><p>验证阶段大致上会完成下面四个阶段的校验动作：文件格式验证、元数据验证、字节码验证和符号引用验证。</p><ol><li><p>文件格式验证：该阶段的主要目的是保证输入的字节流能正确地解析并存储于方法区内，格式上符合一个Java类型信息的要求。</p><ul><li>是否以魔数0xCAFEBABE开头</li><li>主次版本号是否在当前Java虚拟机接收范围之内。</li><li>常量池的常量中是否有不被支持的常量类型</li><li>指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量。</li></ul><p>。。。。。。</p></li><li><p>元数据验证：该阶段的主要目的是对类的元数据信息进行语义校验，保证不与《Java语言规范》定义相悖的元数据信息。</p><ul><li>这个类是否有父类（除了Object类外所有的类都应当有父类）</li><li>这个类的父类是否继承了不被允许继承的类（被final修饰的类）</li><li>如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法</li><li>类中的字段、方法是否与父类产生矛盾（例如覆盖了父类的final字段，或者出现不合规的方法重载，例如方法参数都一样，但返回值类型却不同）</li></ul><p>。。。。。。</p></li><li><p>字节码验证：该阶段的主要目的是通过数据流分析和控制流分析，确定程序语义是合法的、符合逻辑的。在第二阶段（元数据验证）对元数据信息中的数据类型校验完毕后，这个阶段就要对类的方法体（Class文件中的Code属性）进行校验分析，保证被校验的类的方法在运行时不会做出危害虚拟机安全的行为。</p></li><li><p>符号引用验证：发生在虚拟机将符号引用转化为直接引用的时候（解析阶段发生）。主要是对本类自身意外的各类信息进行匹配性验证，验证该类是否缺少或者被禁止访问它依赖的某些外部类、方法、字段等资源。</p><ul><li>符号引用中通过字符串描述的全限定名是否能找到对应的类。</li><li>在指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段。</li><li>符合引用中的类、方法、字段的可访问性，是否可以被当前类访问（如private）</li></ul></li></ol><p>注意：验证阶段是重要但不是必须的，如果程序运行的全部代码都已经被反复使用和验证过，可以使用-Xverify:none参数关闭大部分类的验证措施，缩短虚拟机类加载时间。</p><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>准备阶段正式为类中的<strong>类变量</strong>（static修饰的变量）分配内存并设置类变量的初始值（零值），如果类变量被final关键字修饰，则初始值就不是零值。</p><h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>解析阶段是Java虚拟机将常量池内的符号引用替换为直接引用的过程。</p><blockquote><p>符号引用</p></blockquote><p>以一组符号来描述所引用的目标，引用的目标并不一定是已经加载到虚拟机内存中的内容。而虚拟机并不一定知道所引用类的地址，所以就使用符号代替，到解析阶段就将符号引用转换成数据真正所在的地方（直接引用）</p><blockquote><p>直接引用</p></blockquote><p>如果有了直接引用，那么直接引用的目标一定被加载到了内存中。</p><blockquote><p>四种引用的解析过程（需要回头看理解）</p></blockquote><ol><li>类或接口的解析</li><li>字段解析：本身-&gt;实现的接口（递归向父接口查找）-&gt;继承的类（递归向父类查找）。如果查找成功返回了引用，将会对字段进行权限验证。</li><li>方法解析</li><li>接口方法解析</li></ol><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>在类的初始化阶段，Java虚拟机才真正开始执行类中编写的Java程序代码。</p><p>定义在静态代码块之后的静态变量，在代码块中可以赋值，但是不能够访问，否则会”非法向前引用”错误</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        count = <span class="number">100</span>;</span><br><span class="line">        System.out.println(count); <span class="comment">// illegal forward reference 非法向前引用</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果多个线程同时去初始化一个类，那么只会有其中一个线程去执行这个类的()方法，其他线程都需要阻塞等待，直到活动线程执行完毕<code>&lt;clinit&gt;()</code>方法。</p><p>对于类来说：父类的静态变量、静态代码块-&gt;子类的静态变量、静态代码块-&gt;父类的普通代码块、普通变量-&gt;父类的构造器-&gt;子类的普通代码块、普通变量-&gt;子类的构造器</p><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p>实现”通过一个类的全限定名来获取描述该类的二进制字节流”的代码被称为”类加载器”（Class Loader）</p><h4 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h4><p>对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在Java虚拟机中的唯一性，每一个类加载器都有一个独立的类名称空间。比较两个类（对象）是否”相等“，只有这两个类（对象）是由同一个类加载器加载的前提下才有意义，否则即使这两个类来源于同一个Class文件，被同一个Java虚拟机加载，只要加载他们的类加载器不同，那么这两个类就必定不相等。</p><p>这里所指的“相等”，包括代表类的 Class 对象的 equals()方法、isAssignableFrom()方法、isInstance()方法的返回结果，也包括了使用 instanceof 关键字做对象所属关系判定等各种情况。</p><p>案例：不同类加载器对instanceof关键字运算结果的影响</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> chapter07;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassLoaderDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, InstantiationException, IllegalAccessException &#123;</span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">loader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassLoader</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">filename</span> <span class="operator">=</span> name.substring(name.lastIndexOf(<span class="string">&quot;.&quot;</span>) + <span class="number">1</span>) + <span class="string">&quot;.class&quot;</span>;</span><br><span class="line">                    <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> getClass().getResourceAsStream(filename);</span><br><span class="line">                    <span class="keyword">if</span> (is == <span class="literal">null</span>)&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="built_in">super</span>.loadClass(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[is.available()];</span><br><span class="line">                    is.read(b);</span><br><span class="line">                    <span class="keyword">return</span> defineClass(name, b, <span class="number">0</span>, b.length);</span><br><span class="line">                &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> loader.loadClass(<span class="string">&quot;chapter07.ClassLoaderDemo&quot;</span>).newInstance();</span><br><span class="line">        System.out.println(obj.getClass());</span><br><span class="line">        System.out.println(obj <span class="keyword">instanceof</span> chapter07.ClassLoaderDemo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class chapter07.ClassLoaderDemo</span><br><span class="line">false</span><br></pre></td></tr></table></figure><p>这是因为 Java 虚拟机中同时存在了两个ClassLoaderDemo类，一个是由虚拟机的应用程序类加载器所加载的，另外一个是由我们自定义的类加载器加载的。</p><h4 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h4><blockquote><p>三层类加载器</p></blockquote><ol><li>启动类加载器（Bootstrap Class Loader）：这个类加载器负责加载存放在<code>&lt;JAVA_HOME\lib&gt;</code>目录，或者被-Xbootclasspath参数所指定的路径中存放的，而且是Java虚拟机能够识别的类库（命名规范jar包），加载到虚拟机内存中。</li><li>扩展类加载器（Extension Class Loader）：这个类加载器负责加载<code>&lt;JAVA_HOME\lib\ext&gt;</code>目录中，或者被java.ext.dirs系统变量所指定的路径中所有的类库。</li><li>应用程序类加载器（Application Class Loader）：又被称为”系统类加载器“，主要负责加载用户路径（ClassPath）上的所有类库。如果应用程序中没有定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</li></ol><p><img src="/../img/contentImg/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6%E6%A8%A1%E5%9E%8B.png" alt="双亲委派机制模型"></p><blockquote><p>双亲委派机制的工作过程</p></blockquote><p>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时， 子加载器才会尝试自己去完成加载。</p><h4 id="Java模块化系统"><a href="#Java模块化系统" class="headerlink" title="Java模块化系统"></a>Java模块化系统</h4><blockquote><p>JDK9之后的类加载</p></blockquote><p><img src="/../img/contentImg/jdk9%E5%90%8E%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6.png" alt="JDK9后的类加载器委派机制"></p><p>当平台及应用程序类加载器收到类加载请求，在委派给父加载器加载前，要先判断该类是否能够归属到某一个系统模块中，如果可以找到这样的归属关系，就要优先委派给负责那个模块的加载器完成加载</p><ol><li>经过破坏后的双亲委派模型更加高效，减少了很多类加载器之间不必要的委派操作</li><li>JDK9的模块化可以减少Java程序打包的体积，同时拥有更好的隔离线与封装性</li><li>每个moudle拥有专属的类加载器，程序在并发性上也会更加出色</li></ol><h2 id="虚拟机字节码执行引擎"><a href="#虚拟机字节码执行引擎" class="headerlink" title="虚拟机字节码执行引擎"></a>虚拟机字节码执行引擎</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><blockquote><p>物理机与虚拟机区别</p></blockquote><p>物理机的执行引擎是直接建立在处理器、 缓存、指令集和操作系统层面上的，而虚拟机的执行引擎则是由软件自行实现的，因此 可以不受物理条件制约地定制指令集与执行引擎的结构体系，能够执行那些不被硬件直 接支持的指令集格式。</p><p>所有的 Java 虚拟机的执行引擎输入、输出都是一致的：输入的是字节码二进制流，处理过程是字节码解析执行的等效过程，输出的是执行结果。</p><h3 id="运行时栈帧结构"><a href="#运行时栈帧结构" class="headerlink" title="运行时栈帧结构"></a>运行时栈帧结构</h3><p>Java虚拟机以方法作为最基本的执行单元，”栈帧“是用于支持虚拟机进行方法调用和执行的数据结构。每一个栈帧都包括了局部变量表、操作数栈、动态连接、方法返回地址和一些额外的附加信息。</p><p>在活动线程中，只有位于栈顶的方法才是运行的（当前方法），只有位于栈顶的栈帧才是生效的（当前栈帧）。，执行引擎所运行的所有字节码指令都只针对当前栈帧进行操作。</p><h4 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h4><p>局部变量表（Local Variables Table）是一组变量值的存储空间，用于存放方法参数和方法内部定义的局部变量。在 Java 程序被编译为 Class文件时，就在方法的 Code 属性的 max_locals数据项中确定了该方法所需分配的局部变量表的最大容量。</p><p>局部变量表的容量以变量槽（Variable Slot）为最小单位</p><blockquote><p>Java虚拟机使用局部变量表的方式</p></blockquote><p>Java 虚拟机通过索引定位的方式使用局部变量表，索引值的范围是从 0 开始至局部变量表最大的变量槽数量。如果访问的是 32 位数据类型的变量，索引 N 就代表了使用 第 N 个变量槽，如果访问的是 64 位数据类型的变量，则说明会同时使用第 N 和 N+1 两个变量槽。对于两个相邻的共同存放一个 64 位数据的两个变量槽，虚拟机不允许采用任何方式单独访问其中的某一个。</p><p>当一个方法被调用时，Java 虚拟机会使用局部变量表来完成参数值到参数变量列表 的传递过程，即实参到形参的传递。</p><p>如果方法是实例方法（没有被static修饰），局部变量表中第0位索引的变量槽默认是用于传递该方法所属对象实例的引用（方法中可以通过this关键字访问这个参数）。其余参数则按照参数表顺序传递、分配。参数表分配完毕后，再根据方法体内部定义的变量顺序和作用域分配其余的变量槽。</p><p>变量槽是可以复用的：如果当前字节码 PC 计数器的 值已经超出了某个变量的作用域，那这个变量对应的变量槽就可以交给其他变量来重用。但是这个特点可能会影响到系统的垃圾回收行为。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">byte</span>[] placeholder = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">64</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// int a = 0;</span></span><br><span class="line">    System.gc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释<code>int a = 0</code>的情况下，代码虽然已经离开了placeholder 的作用域，但在此之后，再没有发生过任何对局部变量表的读写操作，placeholder 原本所占用的变量槽还没有被其他变量所复用，所以作为 GC Roots 一部分的局部变量表仍然保持着对它的关联。</p><p>注意：局部变量不像类变量有一个准备阶段，在准备阶段，虚拟机会为类变量赋予零值，如果局部变量没有显示的赋值，它是完全不能使用的。</p><h4 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h4><p>操作数栈（Operand Stack）也常被称为操作栈，它是一个后入先出（Last In First  Out，LIFO）栈。同局部变量表一样，操作数栈的最大深度也在编译的时候被写入到 Code 属性的 max_stacks 数据项之中。</p><p>操作数栈的每一个元素可以是包括long和double在内的任意Java数据类型。32位数据类型所占的栈容量为1，64位数据类型所占的栈容量为2。</p><blockquote><p>操作数栈执行过程</p></blockquote><p>当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令往操作数栈中写入和提取内容，也就是出栈和入栈操作。例如：整数加法的字节码指令 iadd，这条指令在运行的时候要求操作数栈中最接近栈顶的两个元素已经存入了两个 int 型的数值，当执行这个指令时，会把这两个 int 值出栈并相加，然后将相加的结果重新入栈。</p><p>操作数栈中元素的数据类型必须与字节码指令的序列严格匹配。再以上面的 iadd 指令为例，这个指令只能用于整型数的加法，它在执行时，最接近栈顶的两个元素的数据类型必须为 int 型，不能出现一个 long 和一个 float 使用 iadd 命令相加的情况。</p><p>在概念模型中，两个栈帧是完全独立的。但是在具体的虚拟机实现中，会进行优化，令两个栈帧出现一部分重叠。这要做不仅可以节约一定空间，更重要的是在进行方法调用时就可以直接共用一部分数据，无需进行额外的参数复制传递。</p><p><img src="/../img/contentImg/image-20221010215022060.png" alt="两个栈帧之间的数据共享"></p><h4 id="动态连接"><a href="#动态连接" class="headerlink" title="动态连接"></a>动态连接</h4><p>每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。</p><h4 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h4><p>退出方法的两种方式：</p><ol><li>正常调用完成后退出：会给调用者返回值（如果有返回值）</li><li>异常调用完成后退出：不会给调用者返回任何信息</li></ol><p>无论哪种方式退出方法，都必须返回到最初方法被调用时的位置，程序才能继续执行。如何知道调用时的位置？正常退出时，主调方法的PC计数器的值就可以作为方法的返回地址，异常退出时，返回地址需要通过异常处理器确定。</p><p>方法退出时<strong>可能</strong>执行的操作有：</p><ol><li>恢复上层方法的局部变量表和操作数栈</li><li>把返回值（如果有的话）压入调用者栈帧的操作数栈中</li><li>调整 PC 计数器的值以指向方法调用指令后面的一条指令</li></ol><h3 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h3><p>方法调用并不是说方法被执行，方法调用阶段唯一的任务就是确定被调用方法的版本（即调用哪一个方法）</p><h4 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h4><p>所有方法调用的目标方法在Class文件里面都是一个常量池中的符号引用，在类加载的解析阶段，会将其中一部分符号引用转换成直接引用。但是要想能够解析成直接引用，方法在程序真正运行之前就有一个可确定的调用版本，并且这个调用版本在运行期是不可改变的。也就是调用目标在代码写好，编译器编译的那一刻就已经确定下来了。</p><p>上述意思大概总结为“编译期可知，运行期不可变”</p><p>符合上述总结的方法有两大类：</p><ol><li>静态方法：与类直接相关</li><li>私有方法：不可以被其他类访问</li></ol><p>他们都不可能通过继承或别的方式重写出其他版本，因此他们适合在类加载阶段解析。</p><blockquote><p>Java虚拟机调用方法的指令</p></blockquote><ol><li>invokestatic：用于调用静态方法</li><li>invokespecial：用于调用实例构造器<code>&lt;init&gt;()</code>方法、私有方法和父类中的方法</li><li>invokevirtual：用于调用所有的“虚方法”</li><li>invokeinterface：用于调用接口方法，会在运行时再确定一个实现该接口的对象</li><li>invokedynamic：现在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法。</li></ol><p>只要能被invokestatic和invokespecial指令调用的方法，都可以在解析阶段中确定唯一的调用版本。Java中符合这个条件的方法共有静态方法、私有方法、实习构造器、父类方法、被final修饰的方法5种。这5种方法调用会在类加载的时候就可以把符号引用解析为该方法的直接引用，这些方法称为“非虚方法”，其他方法称为“虚方法”。</p><p>解析调用一定是个静态的过程，在编译期间就完全确定，在类加载的解析阶段就会 把涉及的符号引用全部转变为明确的直接引用，不必延迟到运行期再去完成。</p><h4 id="分派"><a href="#分派" class="headerlink" title="分派"></a>分派</h4><p>分派会揭秘Java多态特征的一些体现</p><blockquote><p>静态分派</p></blockquote><p>虚拟机（准确说是编译器）在重载时是通过参数的静态类型而不是实际类型作为判断依据。由于静态类型在编译期可知，所以在编译阶段，Javac编译器就根据参数的静态类型决定了会使用哪个重载版本。</p><p>所有依赖静态类型来决定方法执行版本的分派动作，都称为静态分派。（最典型的就是方法重载）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> chapter08;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OverloadDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Human</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Man</span> <span class="keyword">extends</span> <span class="title class_">Human</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">WoMan</span> <span class="keyword">extends</span> <span class="title class_">Human</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(WoMan woMan)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;woman say hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(Man man)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;man say hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(Human woMan)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;human say hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">OverloadDemo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OverloadDemo</span>();</span><br><span class="line">        <span class="type">Human</span> <span class="variable">woMan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WoMan</span>();</span><br><span class="line">        <span class="type">Human</span> <span class="variable">man</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Man</span>();</span><br><span class="line">        demo.sayHello(woMan);</span><br><span class="line">        demo.sayHello(man);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">human say hello</span><br><span class="line">human say hello</span><br></pre></td></tr></table></figure><blockquote><p>动态分派</p></blockquote><p>动态分配的主要看invokevirtual指令的执行过程</p><ol><li>找到操作数栈顶的第一个元素所指向的对象的实际类型，记作C。</li><li>如果类型C中找到与常量中的描述符和简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用。</li><li>否则，按照继承关系从上往下依次对C的各个父类进行第二步的搜索和验证过程。</li><li>始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常</li></ol><p>正是因为invokevirtual指令的第一步就是在运行期确定接收者的实际类型，所以两次调用中的invokevirtual指令并不是把常量池中方法的符号引用解析到直接引用就结束了，还会根据方法接收者的实际类型选择方法版本。这个过程也是方法&#x3D;&#x3D;重写&#x3D;&#x3D;的本质</p><p>这种多态性的根源来源于虚方法调用指令invokevirtual的执行逻辑，所以只对方法有效，对字段无效。对字段的访问根据静态类型确定。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> chapter08;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FieldHasNoPolymorphic</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="variable">money</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Father</span><span class="params">()</span>&#123;</span><br><span class="line">            money = <span class="number">2</span>;</span><br><span class="line">            showMoney();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showMoney</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;I am father, i have &quot;</span> + money);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="variable">money</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Son</span><span class="params">()</span>&#123;</span><br><span class="line">            money = <span class="number">4</span>;</span><br><span class="line">            showMoney();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showMoney</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;I am Son, i have &quot;</span> + money);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Father</span> <span class="variable">gay</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">        System.out.println(gay.money);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">I am Son, i have 0</span><br><span class="line">I am Son, i have 4</span><br><span class="line">2</span><br></pre></td></tr></table></figure><p>输出两句都是“I am Son”，这是因为 Son 类在创建的时候，首先隐式调用了 Father 的构造函数，而 Father 构造函数中对 showMeTheMoney()的调用是一次虚方法调用，实际执行的版本是 Son::showMeTheMoney()方法，所以输出的是“I am Son”。而这时候虽然父类的 money 字段已经被初始化成 2 了，但 Son::showMeTheMoney()方法中访问的却是子类的 money 字段，这时候结果自然还是 0，因为它要到子类的构造函数执行时才会被初始化。main()的最后一句通过静态 类型访问到了父类中的 money，输出了 2。</p><blockquote><p>单分派与多分派</p></blockquote><p>宗量：方法的接收者与方法的参数的统称</p><p>单分派：根据一个宗量对目标方法进行选择</p><p>多分派：根据多个宗量对目标方法进行选择</p><p>Java语言是静态多分派，动态单分派</p><p>静态：方法重载，不仅要看方法的接收者，还要看参数</p><p>动态：方法重写，只用关心方法接收者</p><blockquote><p>虚拟机动态分配的实现</p></blockquote><p>虚方法表</p><p>虚方法表一般在类加载的连接阶段进行初始化，准备了类的变量初值后，虚拟机会把该类的虚方法表也一同初始化。</p><p><img src="/../img/contentImg/image-20221012130309146.png" alt="虚方法表结构"></p><p>虚方法表中存放的是各个方法的实际入口。如果某个方法在子类中没有被重写，那么子类中虚方法表的入口地址和父类相同方法的地址入口是一样的。父类、子类的虚方法表中，相同签名的方法的索引序号应该一致（方便查找，不用从头查找了）。</p><h3 id="动态语言支持"><a href="#动态语言支持" class="headerlink" title="动态语言支持"></a>动态语言支持</h3><h4 id="java-lang-invoke包"><a href="#java-lang-invoke包" class="headerlink" title="java.lang.invoke包"></a>java.lang.invoke包</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> chapter08;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.invoke.MethodHandle;</span><br><span class="line"><span class="keyword">import</span> java.lang.invoke.MethodHandles;</span><br><span class="line"><span class="keyword">import</span> java.lang.invoke.MethodType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodHandleDemo</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">(String s)</span>&#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> System.currentTimeMillis() % <span class="number">2</span> == <span class="number">0</span> ? System.out : <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        getPrintlnMH(object).invokeExact(<span class="string">&quot;老猪&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> MethodHandle <span class="title function_">getPrintlnMH</span><span class="params">(Object receiver)</span> <span class="keyword">throws</span> Throwable&#123;</span><br><span class="line">        <span class="comment">// 通过Method.methodType()方法，获取一个MethodType实例对象</span></span><br><span class="line">        <span class="comment">//  第一个参数：返回值类型，其余参数：方法参数类型</span></span><br><span class="line">        <span class="comment">// lookup()方法的作用是在指定类中查找符合给定的方法名称、方法类型、并且符合调用权限的方法句柄。</span></span><br><span class="line">        <span class="comment">// findVirtual对应指令invokevirtual，invokevirtual（不是findVirtual）方法第一个参数是隐式的，</span></span><br><span class="line">        <span class="comment">// 代表该方法的接收者，也是this指向的对象，通过bindTo传递</span></span><br><span class="line">        <span class="type">MethodType</span> <span class="variable">mt</span> <span class="operator">=</span> MethodType.methodType(<span class="keyword">void</span>.class, String.class);</span><br><span class="line">        <span class="keyword">return</span> MethodHandles.lookup().findVirtual(receiver.getClass(), <span class="string">&quot;println&quot;</span>, mt).bindTo(receiver);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Reflection和MethodHandle机制的区别：</p><ol><li>Reflection是在模拟Java代码层次的方法调用，而MethodHandle是在模拟字节码层次的方法调用。</li><li>Reflection获得的信息是方法在Java端的全面映像，包含了方法的签名、描述符以及方法属性表中各种属性的Java端表示，还包含了执行权限等运行期信息。而MethodHandle仅包含执行该方法的相关信息。</li></ol><h4 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h4><p>子类访问祖父类中的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> chapter08;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.invoke.MethodHandle;</span><br><span class="line"><span class="keyword">import</span> java.lang.invoke.MethodHandles;</span><br><span class="line"><span class="keyword">import</span> java.lang.invoke.MethodType;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InvokeDynamicDemo</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">GrandPa</span>&#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">thinking</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;i am grandpa&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Father</span> <span class="keyword">extends</span> <span class="title class_">GrandPa</span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">thinking</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;i am father&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">thinking</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">MethodType</span> <span class="variable">mt</span> <span class="operator">=</span> MethodType.methodType(<span class="keyword">void</span>.class);</span><br><span class="line">                <span class="type">Field</span> <span class="variable">implLookup</span> <span class="operator">=</span> MethodHandles.Lookup.class.getDeclaredField(<span class="string">&quot;IMPL_LOOKUP&quot;</span>);</span><br><span class="line">                implLookup.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                <span class="type">MethodHandle</span> <span class="variable">mh</span> <span class="operator">=</span> ((MethodHandles.Lookup)implLookup.get(<span class="literal">null</span>)).findSpecial(GrandPa.class, <span class="string">&quot;thinking&quot;</span>, mt, getClass());</span><br><span class="line">                mh.invoke(<span class="built_in">this</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span>(Throwable e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        (<span class="keyword">new</span> <span class="title class_">InvokeDynamicDemo</span>().<span class="keyword">new</span> <span class="title class_">Son</span>()).thinking();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
